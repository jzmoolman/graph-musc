{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionExecutor = void 0;\n\nvar error_1 = require(\"../error\");\n\nvar retry_strategy_1 = require(\"./retry-strategy\");\n\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\n\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\n\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\n\nvar TransactionExecutor =\n/** @class */\nfunction () {\n  function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n    this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n    this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n    this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n    this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n    this._inFlightTimeoutIds = [];\n\n    this._verifyAfterConstruction();\n  }\n\n  TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n    }).catch(function (error) {\n      var retryStartTimeMs = Date.now();\n      var retryDelayMs = _this._initialRetryDelayMs;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n    });\n  };\n\n  TransactionExecutor.prototype.close = function () {\n    // cancel all existing timeouts to prevent further retries\n    this._inFlightTimeoutIds.forEach(function (timeoutId) {\n      return clearTimeout(timeoutId);\n    });\n\n    this._inFlightTimeoutIds = [];\n  };\n\n  TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n    var _this = this;\n\n    var elapsedTimeMs = Date.now() - retryStartTime;\n\n    if (elapsedTimeMs > this._maxRetryTimeMs || !(0, retry_strategy_1.canRetryOn)(error)) {\n      return Promise.reject(error);\n    }\n\n    return new Promise(function (resolve, reject) {\n      var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n\n      var timeoutId = setTimeout(function () {\n        // filter out this timeoutId when time has come and function is being executed\n        _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) {\n          return id !== timeoutId;\n        });\n\n        _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n      }, nextRetryTime); // add newly created timeoutId to the list of all in-flight timeouts\n\n      _this._inFlightTimeoutIds.push(timeoutId);\n    }).catch(function (error) {\n      var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n      return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n    });\n  };\n\n  TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject) {\n    var _this = this;\n\n    var tx;\n\n    try {\n      tx = transactionCreator();\n    } catch (error) {\n      // failed to create a transaction\n      reject(error);\n      return;\n    }\n\n    var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n\n    resultPromise.then(function (result) {\n      return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n    }).catch(function (error) {\n      return _this._handleTransactionWorkFailure(error, tx, reject);\n    });\n  };\n\n  TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n    try {\n      var result = transactionWork(tx); // user defined callback is supposed to return a promise, but it might not; so to protect against an\n      // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n      // validation step without type checks\n\n      return Promise.resolve(result);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  };\n\n  TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n    if (tx.isOpen()) {\n      // transaction work returned resolved promise and transaction has not been committed/rolled back\n      // try to commit the transaction\n      tx.commit().then(function () {\n        // transaction was committed, return result to the user\n        resolve(result);\n      }).catch(function (error) {\n        // transaction failed to commit, propagate the failure\n        reject(error);\n      });\n    } else {\n      // transaction work returned resolved promise and transaction is already committed/rolled back\n      // return the result returned by given transaction work\n      resolve(result);\n    }\n  };\n\n  TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n    if (tx.isOpen()) {\n      // transaction work failed and the transaction is still open, roll it back and propagate the failure\n      tx.rollback().catch(function (ignore) {// ignore the rollback error\n      }).then(function () {\n        return reject(error);\n      }); // propagate the original error we got from the transaction work\n    } else {\n      // transaction is already rolled back, propagate the error\n      reject(error);\n    }\n  };\n\n  TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n    var jitter = delayMs * this._jitterFactor;\n    var min = delayMs - jitter;\n    var max = delayMs + jitter;\n    return Math.random() * (max - min) + min;\n  };\n\n  TransactionExecutor.prototype._verifyAfterConstruction = function () {\n    if (this._maxRetryTimeMs < 0) {\n      throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n    }\n\n    if (this._initialRetryDelayMs < 0) {\n      throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n    }\n\n    if (this._multiplier < 1.0) {\n      throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n    }\n\n    if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n      throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n    }\n  };\n\n  return TransactionExecutor;\n}();\n\nexports.TransactionExecutor = TransactionExecutor;\n\nfunction _valueOrDefault(value, defaultValue) {\n  if (value || value === 0) {\n    return value;\n  }\n\n  return defaultValue;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TransactionExecutor","error_1","require","retry_strategy_1","DEFAULT_MAX_RETRY_TIME_MS","DEFAULT_INITIAL_RETRY_DELAY_MS","DEFAULT_RETRY_DELAY_MULTIPLIER","DEFAULT_RETRY_DELAY_JITTER_FACTOR","maxRetryTimeMs","initialRetryDelayMs","multiplier","jitterFactor","_maxRetryTimeMs","_valueOrDefault","_initialRetryDelayMs","_multiplier","_jitterFactor","_inFlightTimeoutIds","_verifyAfterConstruction","prototype","execute","transactionCreator","transactionWork","_this","Promise","resolve","reject","_executeTransactionInsidePromise","catch","error","retryStartTimeMs","Date","now","retryDelayMs","_retryTransactionPromise","close","forEach","timeoutId","clearTimeout","retryStartTime","elapsedTimeMs","canRetryOn","nextRetryTime","_computeDelayWithJitter","setTimeout","filter","id","push","nextRetryDelayMs","tx","resultPromise","_safeExecuteTransactionWork","then","result","_handleTransactionWorkSuccess","_handleTransactionWorkFailure","isOpen","commit","rollback","ignore","delayMs","jitter","min","max","Math","random","newError","defaultValue"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-core/lib/internal/transaction-executor.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionExecutor = void 0;\nvar error_1 = require(\"../error\");\nvar retry_strategy_1 = require(\"./retry-strategy\");\nvar DEFAULT_MAX_RETRY_TIME_MS = 30 * 1000; // 30 seconds\nvar DEFAULT_INITIAL_RETRY_DELAY_MS = 1000; // 1 seconds\nvar DEFAULT_RETRY_DELAY_MULTIPLIER = 2.0;\nvar DEFAULT_RETRY_DELAY_JITTER_FACTOR = 0.2;\nvar TransactionExecutor = /** @class */ (function () {\n    function TransactionExecutor(maxRetryTimeMs, initialRetryDelayMs, multiplier, jitterFactor) {\n        this._maxRetryTimeMs = _valueOrDefault(maxRetryTimeMs, DEFAULT_MAX_RETRY_TIME_MS);\n        this._initialRetryDelayMs = _valueOrDefault(initialRetryDelayMs, DEFAULT_INITIAL_RETRY_DELAY_MS);\n        this._multiplier = _valueOrDefault(multiplier, DEFAULT_RETRY_DELAY_MULTIPLIER);\n        this._jitterFactor = _valueOrDefault(jitterFactor, DEFAULT_RETRY_DELAY_JITTER_FACTOR);\n        this._inFlightTimeoutIds = [];\n        this._verifyAfterConstruction();\n    }\n    TransactionExecutor.prototype.execute = function (transactionCreator, transactionWork) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n        }).catch(function (error) {\n            var retryStartTimeMs = Date.now();\n            var retryDelayMs = _this._initialRetryDelayMs;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTimeMs, retryDelayMs);\n        });\n    };\n    TransactionExecutor.prototype.close = function () {\n        // cancel all existing timeouts to prevent further retries\n        this._inFlightTimeoutIds.forEach(function (timeoutId) { return clearTimeout(timeoutId); });\n        this._inFlightTimeoutIds = [];\n    };\n    TransactionExecutor.prototype._retryTransactionPromise = function (transactionCreator, transactionWork, error, retryStartTime, retryDelayMs) {\n        var _this = this;\n        var elapsedTimeMs = Date.now() - retryStartTime;\n        if (elapsedTimeMs > this._maxRetryTimeMs || !(0, retry_strategy_1.canRetryOn)(error)) {\n            return Promise.reject(error);\n        }\n        return new Promise(function (resolve, reject) {\n            var nextRetryTime = _this._computeDelayWithJitter(retryDelayMs);\n            var timeoutId = setTimeout(function () {\n                // filter out this timeoutId when time has come and function is being executed\n                _this._inFlightTimeoutIds = _this._inFlightTimeoutIds.filter(function (id) { return id !== timeoutId; });\n                _this._executeTransactionInsidePromise(transactionCreator, transactionWork, resolve, reject);\n            }, nextRetryTime);\n            // add newly created timeoutId to the list of all in-flight timeouts\n            _this._inFlightTimeoutIds.push(timeoutId);\n        }).catch(function (error) {\n            var nextRetryDelayMs = retryDelayMs * _this._multiplier;\n            return _this._retryTransactionPromise(transactionCreator, transactionWork, error, retryStartTime, nextRetryDelayMs);\n        });\n    };\n    TransactionExecutor.prototype._executeTransactionInsidePromise = function (transactionCreator, transactionWork, resolve, reject) {\n        var _this = this;\n        var tx;\n        try {\n            tx = transactionCreator();\n        }\n        catch (error) {\n            // failed to create a transaction\n            reject(error);\n            return;\n        }\n        var resultPromise = this._safeExecuteTransactionWork(tx, transactionWork);\n        resultPromise\n            .then(function (result) {\n            return _this._handleTransactionWorkSuccess(result, tx, resolve, reject);\n        })\n            .catch(function (error) { return _this._handleTransactionWorkFailure(error, tx, reject); });\n    };\n    TransactionExecutor.prototype._safeExecuteTransactionWork = function (tx, transactionWork) {\n        try {\n            var result = transactionWork(tx);\n            // user defined callback is supposed to return a promise, but it might not; so to protect against an\n            // incorrect API usage we wrap the returned value with a resolved promise; this is effectively a\n            // validation step without type checks\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkSuccess = function (result, tx, resolve, reject) {\n        if (tx.isOpen()) {\n            // transaction work returned resolved promise and transaction has not been committed/rolled back\n            // try to commit the transaction\n            tx.commit()\n                .then(function () {\n                // transaction was committed, return result to the user\n                resolve(result);\n            })\n                .catch(function (error) {\n                // transaction failed to commit, propagate the failure\n                reject(error);\n            });\n        }\n        else {\n            // transaction work returned resolved promise and transaction is already committed/rolled back\n            // return the result returned by given transaction work\n            resolve(result);\n        }\n    };\n    TransactionExecutor.prototype._handleTransactionWorkFailure = function (error, tx, reject) {\n        if (tx.isOpen()) {\n            // transaction work failed and the transaction is still open, roll it back and propagate the failure\n            tx.rollback()\n                .catch(function (ignore) {\n                // ignore the rollback error\n            })\n                .then(function () { return reject(error); }); // propagate the original error we got from the transaction work\n        }\n        else {\n            // transaction is already rolled back, propagate the error\n            reject(error);\n        }\n    };\n    TransactionExecutor.prototype._computeDelayWithJitter = function (delayMs) {\n        var jitter = delayMs * this._jitterFactor;\n        var min = delayMs - jitter;\n        var max = delayMs + jitter;\n        return Math.random() * (max - min) + min;\n    };\n    TransactionExecutor.prototype._verifyAfterConstruction = function () {\n        if (this._maxRetryTimeMs < 0) {\n            throw (0, error_1.newError)('Max retry time should be >= 0: ' + this._maxRetryTimeMs);\n        }\n        if (this._initialRetryDelayMs < 0) {\n            throw (0, error_1.newError)('Initial retry delay should >= 0: ' + this._initialRetryDelayMs);\n        }\n        if (this._multiplier < 1.0) {\n            throw (0, error_1.newError)('Multiplier should be >= 1.0: ' + this._multiplier);\n        }\n        if (this._jitterFactor < 0 || this._jitterFactor > 1) {\n            throw (0, error_1.newError)('Jitter factor should be in [0.0, 1.0]: ' + this._jitterFactor);\n        }\n    };\n    return TransactionExecutor;\n}());\nexports.TransactionExecutor = TransactionExecutor;\nfunction _valueOrDefault(value, defaultValue) {\n    if (value || value === 0) {\n        return value;\n    }\n    return defaultValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}