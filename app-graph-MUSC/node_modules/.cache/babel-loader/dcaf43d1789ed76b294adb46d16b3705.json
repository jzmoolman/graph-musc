{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidRoutingTable = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar _a = neo4j_driver_core_1.internal.constants,\n    WRITE = _a.ACCESS_MODE_WRITE,\n    READ = _a.ACCESS_MODE_READ,\n    ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\n * The routing table object used to determine the role of the servers in the driver.\n */\n\nvar RoutingTable =\n/** @class */\nfunction () {\n  function RoutingTable(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        database = _b.database,\n        routers = _b.routers,\n        readers = _b.readers,\n        writers = _b.writers,\n        expirationTime = _b.expirationTime,\n        ttl = _b.ttl;\n\n    this.database = database || null;\n    this.databaseName = database || 'default database';\n    this.routers = routers || [];\n    this.readers = readers || [];\n    this.writers = writers || [];\n    this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n    this.ttl = ttl;\n  }\n  /**\n   * Create a valid routing table from a raw object\n   *\n   * @param {string} database the database name. It is used for logging purposes\n   * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n   * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n   * @param {RoutingTable} The valid Routing Table\n   */\n\n\n  RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n    return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n  };\n\n  RoutingTable.prototype.forget = function (address) {\n    // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n    // just remove it from the set of readers and writers, so that we don't use it for actual work without\n    // performing discovery first.\n    this.readers = removeFromArray(this.readers, address);\n    this.writers = removeFromArray(this.writers, address);\n  };\n\n  RoutingTable.prototype.forgetRouter = function (address) {\n    this.routers = removeFromArray(this.routers, address);\n  };\n\n  RoutingTable.prototype.forgetWriter = function (address) {\n    this.writers = removeFromArray(this.writers, address);\n  };\n  /**\n   * Check if this routing table is fresh to perform the required operation.\n   * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\n   * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\n   */\n\n\n  RoutingTable.prototype.isStaleFor = function (accessMode) {\n    return this.expirationTime.lessThan(Date.now()) || this.routers.length < MIN_ROUTERS || accessMode === READ && this.readers.length === 0 || accessMode === WRITE && this.writers.length === 0;\n  };\n  /**\n   * Check if this routing table is expired for specified amount of duration\n   *\n   * @param {Integer} duration amount of duration in milliseconds to check for expiration\n   * @returns {boolean}\n   */\n\n\n  RoutingTable.prototype.isExpiredFor = function (duration) {\n    return this.expirationTime.add(duration).lessThan(Date.now());\n  };\n\n  RoutingTable.prototype.allServers = function () {\n    return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n  };\n\n  RoutingTable.prototype.toString = function () {\n    return 'RoutingTable[' + (\"database=\" + this.databaseName + \", \") + (\"expirationTime=\" + this.expirationTime + \", \") + (\"currentTime=\" + Date.now() + \", \") + (\"routers=[\" + this.routers + \"], \") + (\"readers=[\" + this.readers + \"], \") + (\"writers=[\" + this.writers + \"]]\");\n  };\n\n  return RoutingTable;\n}();\n\nexports.default = RoutingTable;\n/**\n * Remove all occurrences of the element in the array.\n * @param {Array} array the array to filter.\n * @param {Object} element the element to remove.\n * @return {Array} new filtered array.\n */\n\nfunction removeFromArray(array, element) {\n  return array.filter(function (item) {\n    return item.asKey() !== element.asKey();\n  });\n}\n/**\n * Create a valid routing table from a raw object\n *\n * @param {string} db the database name. It is used for logging purposes\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n * @param {RoutingTable} The valid Routing Table\n */\n\n\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n  var ttl = rawRoutingTable.ttl;\n  var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n\n  var _a = parseServers(rawRoutingTable, routerAddress),\n      routers = _a.routers,\n      readers = _a.readers,\n      writers = _a.writers;\n\n  assertNonEmpty(routers, 'routers', routerAddress);\n  assertNonEmpty(readers, 'readers', routerAddress);\n  return new RoutingTable({\n    database: database || rawRoutingTable.db,\n    routers: routers,\n    readers: readers,\n    writers: writers,\n    expirationTime: expirationTime,\n    ttl: ttl\n  });\n}\n\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\n * Parse server from the RawRoutingTable.\n *\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\n * @param {string} routerAddress the router address\n * @returns {Object} The object with the list of routers, readers and writers\n */\n\nfunction parseServers(rawRoutingTable, routerAddress) {\n  try {\n    var routers_1 = [];\n    var readers_1 = [];\n    var writers_1 = [];\n    rawRoutingTable.servers.forEach(function (server) {\n      var role = server.role;\n      var addresses = server.addresses;\n\n      if (role === 'ROUTE') {\n        routers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'WRITE') {\n        writers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      } else if (role === 'READ') {\n        readers_1 = parseArray(addresses).map(function (address) {\n          return ServerAddress.fromUrl(address);\n        });\n      }\n    });\n    return {\n      routers: routers_1,\n      readers: readers_1,\n      writers: writers_1\n    };\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Call the expiration time using the ttls from the raw routing table and return it\n *\n * @param {RawRoutingTable} rawRoutingTable the routing table\n * @param {string} routerAddress the router address\n * @returns {number} the ttl\n */\n\n\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n  try {\n    var now = (0, neo4j_driver_core_1.int)(Date.now());\n    var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl).multiply(1000).add(now); // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n\n    if (expires.lessThan(now)) {\n      return neo4j_driver_core_1.Integer.MAX_VALUE;\n    }\n\n    return expires;\n  } catch (error) {\n    throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n  }\n}\n/**\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\n *\n * @param {string[]} serverAddressesArray array of addresses\n * @param {string} serversName the server name\n * @param {string} routerAddress the router address\n */\n\n\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n  if (serverAddressesArray.length === 0) {\n    throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n  }\n}\n\nfunction parseArray(addresses) {\n  if (!Array.isArray(addresses)) {\n    throw new TypeError('Array expected but got: ' + addresses);\n  }\n\n  return Array.from(addresses);\n}","map":{"version":3,"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spreadArray","to","from","pack","arguments","length","l","Array","prototype","slice","concat","Object","defineProperty","exports","createValidRoutingTable","neo4j_driver_core_1","require","_a","internal","constants","WRITE","ACCESS_MODE_WRITE","READ","ACCESS_MODE_READ","ServerAddress","serverAddress","PROTOCOL_ERROR","MIN_ROUTERS","RoutingTable","_b","database","routers","readers","writers","expirationTime","ttl","databaseName","int","fromRawRoutingTable","routerAddress","rawRoutingTable","forget","address","removeFromArray","forgetRouter","forgetWriter","isStaleFor","accessMode","lessThan","Date","now","isExpiredFor","duration","add","allServers","toString","default","array","element","filter","item","asKey","calculateExpirationTime","parseServers","assertNonEmpty","db","routers_1","readers_1","writers_1","servers","forEach","server","role","addresses","parseArray","map","fromUrl","newError","json","stringify","message","expires","multiply","Integer","MAX_VALUE","serverAddressesArray","serversName","isArray","TypeError"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-bolt-connection/lib/rediscovery/routing-table.js"],"sourcesContent":["\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createValidRoutingTable = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar _a = neo4j_driver_core_1.internal.constants, WRITE = _a.ACCESS_MODE_WRITE, READ = _a.ACCESS_MODE_READ, ServerAddress = neo4j_driver_core_1.internal.serverAddress.ServerAddress;\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar MIN_ROUTERS = 1;\n/**\n * The routing table object used to determine the role of the servers in the driver.\n */\nvar RoutingTable = /** @class */ (function () {\n    function RoutingTable(_a) {\n        var _b = _a === void 0 ? {} : _a, database = _b.database, routers = _b.routers, readers = _b.readers, writers = _b.writers, expirationTime = _b.expirationTime, ttl = _b.ttl;\n        this.database = database || null;\n        this.databaseName = database || 'default database';\n        this.routers = routers || [];\n        this.readers = readers || [];\n        this.writers = writers || [];\n        this.expirationTime = expirationTime || (0, neo4j_driver_core_1.int)(0);\n        this.ttl = ttl;\n    }\n    /**\n     * Create a valid routing table from a raw object\n     *\n     * @param {string} database the database name. It is used for logging purposes\n     * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n     * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n     * @param {RoutingTable} The valid Routing Table\n     */\n    RoutingTable.fromRawRoutingTable = function (database, routerAddress, rawRoutingTable) {\n        return createValidRoutingTable(database, routerAddress, rawRoutingTable);\n    };\n    RoutingTable.prototype.forget = function (address) {\n        // Don't remove it from the set of routers, since that might mean we lose our ability to re-discover,\n        // just remove it from the set of readers and writers, so that we don't use it for actual work without\n        // performing discovery first.\n        this.readers = removeFromArray(this.readers, address);\n        this.writers = removeFromArray(this.writers, address);\n    };\n    RoutingTable.prototype.forgetRouter = function (address) {\n        this.routers = removeFromArray(this.routers, address);\n    };\n    RoutingTable.prototype.forgetWriter = function (address) {\n        this.writers = removeFromArray(this.writers, address);\n    };\n    /**\n     * Check if this routing table is fresh to perform the required operation.\n     * @param {string} accessMode the type of operation. Allowed values are {@link READ} and {@link WRITE}.\n     * @return {boolean} `true` when this table contains servers to serve the required operation, `false` otherwise.\n     */\n    RoutingTable.prototype.isStaleFor = function (accessMode) {\n        return (this.expirationTime.lessThan(Date.now()) ||\n            this.routers.length < MIN_ROUTERS ||\n            (accessMode === READ && this.readers.length === 0) ||\n            (accessMode === WRITE && this.writers.length === 0));\n    };\n    /**\n     * Check if this routing table is expired for specified amount of duration\n     *\n     * @param {Integer} duration amount of duration in milliseconds to check for expiration\n     * @returns {boolean}\n     */\n    RoutingTable.prototype.isExpiredFor = function (duration) {\n        return this.expirationTime.add(duration).lessThan(Date.now());\n    };\n    RoutingTable.prototype.allServers = function () {\n        return __spreadArray(__spreadArray(__spreadArray([], __read(this.routers), false), __read(this.readers), false), __read(this.writers), false);\n    };\n    RoutingTable.prototype.toString = function () {\n        return ('RoutingTable[' +\n            (\"database=\" + this.databaseName + \", \") +\n            (\"expirationTime=\" + this.expirationTime + \", \") +\n            (\"currentTime=\" + Date.now() + \", \") +\n            (\"routers=[\" + this.routers + \"], \") +\n            (\"readers=[\" + this.readers + \"], \") +\n            (\"writers=[\" + this.writers + \"]]\"));\n    };\n    return RoutingTable;\n}());\nexports.default = RoutingTable;\n/**\n * Remove all occurrences of the element in the array.\n * @param {Array} array the array to filter.\n * @param {Object} element the element to remove.\n * @return {Array} new filtered array.\n */\nfunction removeFromArray(array, element) {\n    return array.filter(function (item) { return item.asKey() !== element.asKey(); });\n}\n/**\n * Create a valid routing table from a raw object\n *\n * @param {string} db the database name. It is used for logging purposes\n * @param {ServerAddress} routerAddress The router address, it is used for loggin purposes\n * @param {RawRoutingTable} rawRoutingTable Method used to get the raw routing table to be processed\n * @param {RoutingTable} The valid Routing Table\n */\nfunction createValidRoutingTable(database, routerAddress, rawRoutingTable) {\n    var ttl = rawRoutingTable.ttl;\n    var expirationTime = calculateExpirationTime(rawRoutingTable, routerAddress);\n    var _a = parseServers(rawRoutingTable, routerAddress), routers = _a.routers, readers = _a.readers, writers = _a.writers;\n    assertNonEmpty(routers, 'routers', routerAddress);\n    assertNonEmpty(readers, 'readers', routerAddress);\n    return new RoutingTable({\n        database: database || rawRoutingTable.db,\n        routers: routers,\n        readers: readers,\n        writers: writers,\n        expirationTime: expirationTime,\n        ttl: ttl\n    });\n}\nexports.createValidRoutingTable = createValidRoutingTable;\n/**\n * Parse server from the RawRoutingTable.\n *\n * @param {RawRoutingTable} rawRoutingTable the raw routing table\n * @param {string} routerAddress the router address\n * @returns {Object} The object with the list of routers, readers and writers\n */\nfunction parseServers(rawRoutingTable, routerAddress) {\n    try {\n        var routers_1 = [];\n        var readers_1 = [];\n        var writers_1 = [];\n        rawRoutingTable.servers.forEach(function (server) {\n            var role = server.role;\n            var addresses = server.addresses;\n            if (role === 'ROUTE') {\n                routers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n            else if (role === 'WRITE') {\n                writers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n            else if (role === 'READ') {\n                readers_1 = parseArray(addresses).map(function (address) {\n                    return ServerAddress.fromUrl(address);\n                });\n            }\n        });\n        return {\n            routers: routers_1,\n            readers: readers_1,\n            writers: writers_1\n        };\n    }\n    catch (error) {\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse servers entry from router \" + routerAddress + \" from addresses:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable.servers) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n    }\n}\n/**\n * Call the expiration time using the ttls from the raw routing table and return it\n *\n * @param {RawRoutingTable} rawRoutingTable the routing table\n * @param {string} routerAddress the router address\n * @returns {number} the ttl\n */\nfunction calculateExpirationTime(rawRoutingTable, routerAddress) {\n    try {\n        var now = (0, neo4j_driver_core_1.int)(Date.now());\n        var expires = (0, neo4j_driver_core_1.int)(rawRoutingTable.ttl)\n            .multiply(1000)\n            .add(now);\n        // if the server uses a really big expire time like Long.MAX_VALUE this may have overflowed\n        if (expires.lessThan(now)) {\n            return neo4j_driver_core_1.Integer.MAX_VALUE;\n        }\n        return expires;\n    }\n    catch (error) {\n        throw (0, neo4j_driver_core_1.newError)(\"Unable to parse TTL entry from router \" + routerAddress + \" from raw routing table:\\n\" + neo4j_driver_core_1.json.stringify(rawRoutingTable) + \"\\nError message: \" + error.message, PROTOCOL_ERROR);\n    }\n}\n/**\n * Assert if serverAddressesArray is not empty, throws and PROTOCOL_ERROR otherwise\n *\n * @param {string[]} serverAddressesArray array of addresses\n * @param {string} serversName the server name\n * @param {string} routerAddress the router address\n */\nfunction assertNonEmpty(serverAddressesArray, serversName, routerAddress) {\n    if (serverAddressesArray.length === 0) {\n        throw (0, neo4j_driver_core_1.newError)('Received no ' + serversName + ' from router ' + routerAddress, PROTOCOL_ERROR);\n    }\n}\nfunction parseArray(addresses) {\n    if (!Array.isArray(addresses)) {\n        throw new TypeError('Array expected but got: ' + addresses);\n    }\n    return Array.from(addresses);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}