{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar channel_1 = require(\"../channel\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\n\nvar Structure =\n/** @class */\nfunction () {\n  /**\n   * Create new instance\n   */\n  function Structure(signature, fields) {\n    this.signature = signature;\n    this.fields = fields;\n  }\n\n  Structure.prototype.toString = function () {\n    var fieldStr = '';\n\n    for (var i = 0; i < this.fields.length; i++) {\n      if (i > 0) {\n        fieldStr += ', ';\n      }\n\n      fieldStr += this.fields[i];\n    }\n\n    return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n  };\n\n  return Structure;\n}();\n\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\n\nvar Packer =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {Chunker} channel the chunker backed by a network channel.\n   */\n  function Packer(channel) {\n    this._ch = channel;\n    this._byteArraysSupported = true;\n  }\n  /**\n   * Creates a packable function out of the provided value\n   * @param x the value to pack\n   * @returns Function\n   */\n\n\n  Packer.prototype.packable = function (x) {\n    var _this = this;\n\n    if (x === null) {\n      return function () {\n        return _this._ch.writeUInt8(NULL);\n      };\n    } else if (x === true) {\n      return function () {\n        return _this._ch.writeUInt8(TRUE);\n      };\n    } else if (x === false) {\n      return function () {\n        return _this._ch.writeUInt8(FALSE);\n      };\n    } else if (typeof x === 'number') {\n      return function () {\n        return _this.packFloat(x);\n      };\n    } else if (typeof x === 'string') {\n      return function () {\n        return _this.packString(x);\n      };\n    } else if (typeof x === 'bigint') {\n      return function () {\n        return _this.packInteger((0, neo4j_driver_core_1.int)(x));\n      };\n    } else if ((0, neo4j_driver_core_1.isInt)(x)) {\n      return function () {\n        return _this.packInteger(x);\n      };\n    } else if (x instanceof Int8Array) {\n      return function () {\n        return _this.packBytes(x);\n      };\n    } else if (x instanceof Array) {\n      return function () {\n        _this.packListHeader(x.length);\n\n        for (var i_1 = 0; i_1 < x.length; i_1++) {\n          _this.packable(x[i_1] === undefined ? null : x[i_1])();\n        }\n      };\n    } else if (isIterable(x)) {\n      return this.packableIterable(x);\n    } else if (x instanceof neo4j_driver_core_1.Node) {\n      return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Relationship) {\n      return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n    } else if (x instanceof neo4j_driver_core_1.Path) {\n      return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n    } else if (x instanceof Structure) {\n      var packableFields = [];\n\n      for (var i = 0; i < x.fields.length; i++) {\n        packableFields[i] = this.packable(x.fields[i]);\n      }\n\n      return function () {\n        return _this.packStruct(x.signature, packableFields);\n      };\n    } else if (typeof x === 'object') {\n      return function () {\n        var keys = Object.keys(x);\n        var count = 0;\n\n        for (var i_2 = 0; i_2 < keys.length; i_2++) {\n          if (x[keys[i_2]] !== undefined) {\n            count++;\n          }\n        }\n\n        _this.packMapHeader(count);\n\n        for (var i_3 = 0; i_3 < keys.length; i_3++) {\n          var key = keys[i_3];\n\n          if (x[key] !== undefined) {\n            _this.packString(key);\n\n            _this.packable(x[key])();\n          }\n        }\n      };\n    } else {\n      return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n    }\n  };\n\n  Packer.prototype.packableIterable = function (iterable) {\n    try {\n      var array = Array.from(iterable);\n      return this.packable(array);\n    } catch (e) {\n      // handle errors from iterable to array conversion\n      throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n    }\n  };\n  /**\n   * Packs a struct\n   * @param signature the signature of the struct\n   * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n   */\n\n\n  Packer.prototype.packStruct = function (signature, packableFields) {\n    packableFields = packableFields || [];\n    this.packStructHeader(packableFields.length, signature);\n\n    for (var i = 0; i < packableFields.length; i++) {\n      packableFields[i]();\n    }\n  };\n\n  Packer.prototype.packInteger = function (x) {\n    var high = x.high;\n    var low = x.low;\n\n    if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n      this._ch.writeUInt8(INT_8);\n\n      this._ch.writeInt8(low);\n    } else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n      this._ch.writeUInt8(INT_16);\n\n      this._ch.writeInt16(low);\n    } else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n      this._ch.writeUInt8(INT_32);\n\n      this._ch.writeInt32(low);\n    } else {\n      this._ch.writeUInt8(INT_64);\n\n      this._ch.writeInt32(high);\n\n      this._ch.writeInt32(low);\n    }\n  };\n\n  Packer.prototype.packFloat = function (x) {\n    this._ch.writeUInt8(FLOAT_64);\n\n    this._ch.writeFloat64(x);\n  };\n\n  Packer.prototype.packString = function (x) {\n    var bytes = channel_1.utf8.encode(x);\n    var size = bytes.length;\n\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRING | size);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRING_8);\n\n      this._ch.writeUInt8(size);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRING_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n\n      this._ch.writeBytes(bytes);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(STRING_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n\n      this._ch.writeBytes(bytes);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packListHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_LIST | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(LIST_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(LIST_16);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(LIST_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packBytes = function (array) {\n    if (this._byteArraysSupported) {\n      this.packBytesHeader(array.length);\n\n      for (var i = 0; i < array.length; i++) {\n        this._ch.writeInt8(array[i]);\n      }\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n    }\n  };\n\n  Packer.prototype.packBytesHeader = function (size) {\n    if (size < 0x100) {\n      this._ch.writeUInt8(BYTES_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(BYTES_16);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(BYTES_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packMapHeader = function (size) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_MAP | size);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(MAP_8);\n\n      this._ch.writeUInt8(size);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(MAP_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n    } else if (size < 0x100000000) {\n      this._ch.writeUInt8(MAP_32);\n\n      this._ch.writeUInt8((size / 16777216 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 65536 >> 0) % 256);\n\n      this._ch.writeUInt8((size / 256 >> 0) % 256);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.packStructHeader = function (size, signature) {\n    if (size < 0x10) {\n      this._ch.writeUInt8(TINY_STRUCT | size);\n\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x100) {\n      this._ch.writeUInt8(STRUCT_8);\n\n      this._ch.writeUInt8(size);\n\n      this._ch.writeUInt8(signature);\n    } else if (size < 0x10000) {\n      this._ch.writeUInt8(STRUCT_16);\n\n      this._ch.writeUInt8(size / 256 >> 0);\n\n      this._ch.writeUInt8(size % 256);\n    } else {\n      throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n    }\n  };\n\n  Packer.prototype.disableByteArrays = function () {\n    this._byteArraysSupported = false;\n  };\n\n  Packer.prototype._nonPackableValue = function (message) {\n    return function () {\n      throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n    };\n  };\n\n  return Packer;\n}();\n\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\n\nvar Unpacker =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n\n    this._disableLosslessIntegers = disableLosslessIntegers;\n    this._useBigInt = useBigInt;\n  }\n\n  Unpacker.prototype.unpack = function (buffer) {\n    var marker = buffer.readUInt8();\n    var markerHigh = marker & 0xf0;\n    var markerLow = marker & 0x0f;\n\n    if (marker === NULL) {\n      return null;\n    }\n\n    var boolean = this._unpackBoolean(marker);\n\n    if (boolean !== null) {\n      return boolean;\n    }\n\n    var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n\n    if (numberOrInteger !== null) {\n      if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n        if (this._useBigInt) {\n          return numberOrInteger.toBigInt();\n        } else if (this._disableLosslessIntegers) {\n          return numberOrInteger.toNumberOrInfinity();\n        }\n      }\n\n      return numberOrInteger;\n    }\n\n    var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n\n    if (string !== null) {\n      return string;\n    }\n\n    var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n\n    if (list !== null) {\n      return list;\n    }\n\n    var byteArray = this._unpackByteArray(marker, buffer);\n\n    if (byteArray !== null) {\n      return byteArray;\n    }\n\n    var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n\n    if (map !== null) {\n      return map;\n    }\n\n    var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n\n    if (struct !== null) {\n      return struct;\n    }\n\n    throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n  };\n\n  Unpacker.prototype.unpackInteger = function (buffer) {\n    var marker = buffer.readUInt8();\n\n    var result = this._unpackInteger(marker, buffer);\n\n    if (result == null) {\n      throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n    }\n\n    return result;\n  };\n\n  Unpacker.prototype._unpackBoolean = function (marker) {\n    if (marker === TRUE) {\n      return true;\n    } else if (marker === FALSE) {\n      return false;\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n    if (marker === FLOAT_64) {\n      return buffer.readFloat64();\n    } else {\n      return this._unpackInteger(marker, buffer);\n    }\n  };\n\n  Unpacker.prototype._unpackInteger = function (marker, buffer) {\n    if (marker >= 0 && marker < 128) {\n      return (0, neo4j_driver_core_1.int)(marker);\n    } else if (marker >= 240 && marker < 256) {\n      return (0, neo4j_driver_core_1.int)(marker - 256);\n    } else if (marker === INT_8) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n    } else if (marker === INT_16) {\n      return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n    } else if (marker === INT_32) {\n      var b = buffer.readInt32();\n      return (0, neo4j_driver_core_1.int)(b);\n    } else if (marker === INT_64) {\n      var high = buffer.readInt32();\n      var low = buffer.readInt32();\n      return new neo4j_driver_core_1.Integer(low, high);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRING) {\n      return channel_1.utf8.decode(buffer, markerLow);\n    } else if (marker === STRING_8) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt8());\n    } else if (marker === STRING_16) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt16());\n    } else if (marker === STRING_32) {\n      return channel_1.utf8.decode(buffer, buffer.readUInt32());\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_LIST) {\n      return this._unpackListWithSize(markerLow, buffer);\n    } else if (marker === LIST_8) {\n      return this._unpackListWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === LIST_16) {\n      return this._unpackListWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === LIST_32) {\n      return this._unpackListWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n    var value = [];\n\n    for (var i = 0; i < size; i++) {\n      value.push(this.unpack(buffer));\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n    if (marker === BYTES_8) {\n      return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === BYTES_16) {\n      return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === BYTES_32) {\n      return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n    var value = new Int8Array(size);\n\n    for (var i = 0; i < size; i++) {\n      value[i] = buffer.readInt8();\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_MAP) {\n      return this._unpackMapWithSize(markerLow, buffer);\n    } else if (marker === MAP_8) {\n      return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === MAP_16) {\n      return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n    } else if (marker === MAP_32) {\n      return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n    var value = {};\n\n    for (var i = 0; i < size; i++) {\n      var key = this.unpack(buffer);\n      value[key] = this.unpack(buffer);\n    }\n\n    return value;\n  };\n\n  Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n    if (markerHigh === TINY_STRUCT) {\n      return this._unpackStructWithSize(markerLow, buffer);\n    } else if (marker === STRUCT_8) {\n      return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n    } else if (marker === STRUCT_16) {\n      return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n    } else {\n      return null;\n    }\n  };\n\n  Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n    var signature = buffer.readUInt8();\n\n    if (signature === NODE) {\n      return this._unpackNode(structSize, buffer);\n    } else if (signature === RELATIONSHIP) {\n      return this._unpackRelationship(structSize, buffer);\n    } else if (signature === UNBOUND_RELATIONSHIP) {\n      return this._unpackUnboundRelationship(structSize, buffer);\n    } else if (signature === PATH) {\n      return this._unpackPath(structSize, buffer);\n    } else {\n      return this._unpackUnknownStruct(signature, structSize, buffer);\n    }\n  };\n\n  Unpacker.prototype._unpackNode = function (structSize, buffer) {\n    this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.Node(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Labels\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n    this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.Relationship(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Start Node Identity\n    this.unpack(buffer), // End Node Identity\n    this.unpack(buffer), // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n    this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n\n    return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer), // Identity\n    this.unpack(buffer), // Type\n    this.unpack(buffer) // Properties\n    );\n  };\n\n  Unpacker.prototype._unpackPath = function (structSize, buffer) {\n    this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n\n    var nodes = this.unpack(buffer);\n    var rels = this.unpack(buffer);\n    var sequence = this.unpack(buffer);\n    var segments = [];\n    var prevNode = nodes[0];\n\n    for (var i = 0; i < sequence.length; i += 2) {\n      var nextNode = nodes[sequence[i + 1]];\n      var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n      var rel = void 0;\n\n      if (relIndex > 0) {\n        rel = rels[relIndex - 1];\n\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // To avoid duplication, relationships in a path do not contain\n          // information about their start and end nodes, that's instead\n          // inferred from the path sequence. This is us inferring (and,\n          // for performance reasons remembering) the start/end of a rel.\n          rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n        }\n      } else {\n        rel = rels[-relIndex - 1];\n\n        if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n          // See above\n          rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n        }\n      } // Done hydrating one path segment.\n\n\n      segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n      prevNode = nextNode;\n    }\n\n    return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n  };\n\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    var result = new Structure(signature, []);\n\n    for (var i = 0; i < structSize; i++) {\n      result.fields.push(this.unpack(buffer));\n    }\n\n    return result;\n  };\n\n  Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n    if (expectedSize !== actualSize) {\n      throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n    }\n  };\n\n  return Unpacker;\n}();\n\nexports.Unpacker = Unpacker;\n\nfunction isIterable(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return typeof obj[Symbol.iterator] === 'function';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Structure","Unpacker","Packer","channel_1","require","neo4j_driver_core_1","PROTOCOL_ERROR","error","TINY_STRING","TINY_LIST","TINY_MAP","TINY_STRUCT","NULL","FLOAT_64","FALSE","TRUE","INT_8","INT_16","INT_32","INT_64","STRING_8","STRING_16","STRING_32","LIST_8","LIST_16","LIST_32","BYTES_8","BYTES_16","BYTES_32","MAP_8","MAP_16","MAP_32","STRUCT_8","STRUCT_16","NODE","NODE_STRUCT_SIZE","RELATIONSHIP","RELATIONSHIP_STRUCT_SIZE","UNBOUND_RELATIONSHIP","UNBOUND_RELATIONSHIP_STRUCT_SIZE","PATH","PATH_STRUCT_SIZE","signature","fields","prototype","toString","fieldStr","i","length","channel","_ch","_byteArraysSupported","packable","x","_this","writeUInt8","packFloat","packString","packInteger","int","isInt","Int8Array","packBytes","Array","packListHeader","i_1","undefined","isIterable","packableIterable","Node","_nonPackableValue","Relationship","Path","packableFields","packStruct","keys","count","i_2","packMapHeader","i_3","key","iterable","array","from","e","newError","message","packStructHeader","high","low","greaterThanOrEqual","lessThan","writeInt8","writeInt16","writeInt32","writeFloat64","bytes","utf8","encode","size","writeBytes","packBytesHeader","disableByteArrays","disableLosslessIntegers","useBigInt","_disableLosslessIntegers","_useBigInt","unpack","buffer","marker","readUInt8","markerHigh","markerLow","boolean","_unpackBoolean","numberOrInteger","_unpackNumberOrInteger","toBigInt","toNumberOrInfinity","string","_unpackString","list","_unpackList","byteArray","_unpackByteArray","map","_unpackMap","struct","_unpackStruct","unpackInteger","result","_unpackInteger","readFloat64","readInt8","readInt16","b","readInt32","Integer","decode","readUInt16","readUInt32","_unpackListWithSize","push","_unpackByteArrayWithSize","_unpackMapWithSize","_unpackStructWithSize","structSize","_unpackNode","_unpackRelationship","_unpackUnboundRelationship","_unpackPath","_unpackUnknownStruct","_verifyStructSize","UnboundRelationship","nodes","rels","sequence","segments","prevNode","nextNode","relIndex","toNumber","rel","bind","identity","PathSegment","structName","expectedSize","actualSize","obj","Symbol","iterator"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v1.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Structure = exports.Unpacker = exports.Packer = void 0;\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar PROTOCOL_ERROR = neo4j_driver_core_1.error.PROTOCOL_ERROR;\nvar TINY_STRING = 0x80;\nvar TINY_LIST = 0x90;\nvar TINY_MAP = 0xa0;\nvar TINY_STRUCT = 0xb0;\nvar NULL = 0xc0;\nvar FLOAT_64 = 0xc1;\nvar FALSE = 0xc2;\nvar TRUE = 0xc3;\nvar INT_8 = 0xc8;\nvar INT_16 = 0xc9;\nvar INT_32 = 0xca;\nvar INT_64 = 0xcb;\nvar STRING_8 = 0xd0;\nvar STRING_16 = 0xd1;\nvar STRING_32 = 0xd2;\nvar LIST_8 = 0xd4;\nvar LIST_16 = 0xd5;\nvar LIST_32 = 0xd6;\nvar BYTES_8 = 0xcc;\nvar BYTES_16 = 0xcd;\nvar BYTES_32 = 0xce;\nvar MAP_8 = 0xd8;\nvar MAP_16 = 0xd9;\nvar MAP_32 = 0xda;\nvar STRUCT_8 = 0xdc;\nvar STRUCT_16 = 0xdd;\nvar NODE = 0x4e;\nvar NODE_STRUCT_SIZE = 3;\nvar RELATIONSHIP = 0x52;\nvar RELATIONSHIP_STRUCT_SIZE = 5;\nvar UNBOUND_RELATIONSHIP = 0x72;\nvar UNBOUND_RELATIONSHIP_STRUCT_SIZE = 3;\nvar PATH = 0x50;\nvar PATH_STRUCT_SIZE = 3;\n/**\n * A Structure have a signature and fields.\n * @access private\n */\nvar Structure = /** @class */ (function () {\n    /**\n     * Create new instance\n     */\n    function Structure(signature, fields) {\n        this.signature = signature;\n        this.fields = fields;\n    }\n    Structure.prototype.toString = function () {\n        var fieldStr = '';\n        for (var i = 0; i < this.fields.length; i++) {\n            if (i > 0) {\n                fieldStr += ', ';\n            }\n            fieldStr += this.fields[i];\n        }\n        return 'Structure(' + this.signature + ', [' + fieldStr + '])';\n    };\n    return Structure;\n}());\nexports.Structure = Structure;\n/**\n * Class to pack\n * @access private\n */\nvar Packer = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Chunker} channel the chunker backed by a network channel.\n     */\n    function Packer(channel) {\n        this._ch = channel;\n        this._byteArraysSupported = true;\n    }\n    /**\n     * Creates a packable function out of the provided value\n     * @param x the value to pack\n     * @returns Function\n     */\n    Packer.prototype.packable = function (x) {\n        var _this = this;\n        if (x === null) {\n            return function () { return _this._ch.writeUInt8(NULL); };\n        }\n        else if (x === true) {\n            return function () { return _this._ch.writeUInt8(TRUE); };\n        }\n        else if (x === false) {\n            return function () { return _this._ch.writeUInt8(FALSE); };\n        }\n        else if (typeof x === 'number') {\n            return function () { return _this.packFloat(x); };\n        }\n        else if (typeof x === 'string') {\n            return function () { return _this.packString(x); };\n        }\n        else if (typeof x === 'bigint') {\n            return function () { return _this.packInteger((0, neo4j_driver_core_1.int)(x)); };\n        }\n        else if ((0, neo4j_driver_core_1.isInt)(x)) {\n            return function () { return _this.packInteger(x); };\n        }\n        else if (x instanceof Int8Array) {\n            return function () { return _this.packBytes(x); };\n        }\n        else if (x instanceof Array) {\n            return function () {\n                _this.packListHeader(x.length);\n                for (var i_1 = 0; i_1 < x.length; i_1++) {\n                    _this.packable(x[i_1] === undefined ? null : x[i_1])();\n                }\n            };\n        }\n        else if (isIterable(x)) {\n            return this.packableIterable(x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Node) {\n            return this._nonPackableValue(\"It is not allowed to pass nodes in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Relationship) {\n            return this._nonPackableValue(\"It is not allowed to pass relationships in query parameters, given: \" + x);\n        }\n        else if (x instanceof neo4j_driver_core_1.Path) {\n            return this._nonPackableValue(\"It is not allowed to pass paths in query parameters, given: \" + x);\n        }\n        else if (x instanceof Structure) {\n            var packableFields = [];\n            for (var i = 0; i < x.fields.length; i++) {\n                packableFields[i] = this.packable(x.fields[i]);\n            }\n            return function () { return _this.packStruct(x.signature, packableFields); };\n        }\n        else if (typeof x === 'object') {\n            return function () {\n                var keys = Object.keys(x);\n                var count = 0;\n                for (var i_2 = 0; i_2 < keys.length; i_2++) {\n                    if (x[keys[i_2]] !== undefined) {\n                        count++;\n                    }\n                }\n                _this.packMapHeader(count);\n                for (var i_3 = 0; i_3 < keys.length; i_3++) {\n                    var key = keys[i_3];\n                    if (x[key] !== undefined) {\n                        _this.packString(key);\n                        _this.packable(x[key])();\n                    }\n                }\n            };\n        }\n        else {\n            return this._nonPackableValue(\"Unable to pack the given value: \" + x);\n        }\n    };\n    Packer.prototype.packableIterable = function (iterable) {\n        try {\n            var array = Array.from(iterable);\n            return this.packable(array);\n        }\n        catch (e) {\n            // handle errors from iterable to array conversion\n            throw (0, neo4j_driver_core_1.newError)(\"Cannot pack given iterable, \" + e.message + \": \" + iterable);\n        }\n    };\n    /**\n     * Packs a struct\n     * @param signature the signature of the struct\n     * @param packableFields the fields of the struct, make sure you call `packable on all fields`\n     */\n    Packer.prototype.packStruct = function (signature, packableFields) {\n        packableFields = packableFields || [];\n        this.packStructHeader(packableFields.length, signature);\n        for (var i = 0; i < packableFields.length; i++) {\n            packableFields[i]();\n        }\n    };\n    Packer.prototype.packInteger = function (x) {\n        var high = x.high;\n        var low = x.low;\n        if (x.greaterThanOrEqual(-0x10) && x.lessThan(0x80)) {\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80) && x.lessThan(-0x10)) {\n            this._ch.writeUInt8(INT_8);\n            this._ch.writeInt8(low);\n        }\n        else if (x.greaterThanOrEqual(-0x8000) && x.lessThan(0x8000)) {\n            this._ch.writeUInt8(INT_16);\n            this._ch.writeInt16(low);\n        }\n        else if (x.greaterThanOrEqual(-0x80000000) && x.lessThan(0x80000000)) {\n            this._ch.writeUInt8(INT_32);\n            this._ch.writeInt32(low);\n        }\n        else {\n            this._ch.writeUInt8(INT_64);\n            this._ch.writeInt32(high);\n            this._ch.writeInt32(low);\n        }\n    };\n    Packer.prototype.packFloat = function (x) {\n        this._ch.writeUInt8(FLOAT_64);\n        this._ch.writeFloat64(x);\n    };\n    Packer.prototype.packString = function (x) {\n        var bytes = channel_1.utf8.encode(x);\n        var size = bytes.length;\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRING | size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRING_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRING_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(STRING_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n            this._ch.writeBytes(bytes);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('UTF-8 strings of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packListHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_LIST | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(LIST_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(LIST_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(LIST_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Lists of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packBytes = function (array) {\n        if (this._byteArraysSupported) {\n            this.packBytesHeader(array.length);\n            for (var i = 0; i < array.length; i++) {\n                this._ch.writeInt8(array[i]);\n            }\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays are not supported by the database this driver is connected to');\n        }\n    };\n    Packer.prototype.packBytesHeader = function (size) {\n        if (size < 0x100) {\n            this._ch.writeUInt8(BYTES_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(BYTES_16);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(BYTES_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Byte arrays of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packMapHeader = function (size) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_MAP | size);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(MAP_8);\n            this._ch.writeUInt8(size);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(MAP_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else if (size < 0x100000000) {\n            this._ch.writeUInt8(MAP_32);\n            this._ch.writeUInt8(((size / 16777216) >> 0) % 256);\n            this._ch.writeUInt8(((size / 65536) >> 0) % 256);\n            this._ch.writeUInt8(((size / 256) >> 0) % 256);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Maps of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.packStructHeader = function (size, signature) {\n        if (size < 0x10) {\n            this._ch.writeUInt8(TINY_STRUCT | size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x100) {\n            this._ch.writeUInt8(STRUCT_8);\n            this._ch.writeUInt8(size);\n            this._ch.writeUInt8(signature);\n        }\n        else if (size < 0x10000) {\n            this._ch.writeUInt8(STRUCT_16);\n            this._ch.writeUInt8((size / 256) >> 0);\n            this._ch.writeUInt8(size % 256);\n        }\n        else {\n            throw (0, neo4j_driver_core_1.newError)('Structures of size ' + size + ' are not supported');\n        }\n    };\n    Packer.prototype.disableByteArrays = function () {\n        this._byteArraysSupported = false;\n    };\n    Packer.prototype._nonPackableValue = function (message) {\n        return function () {\n            throw (0, neo4j_driver_core_1.newError)(message, PROTOCOL_ERROR);\n        };\n    };\n    return Packer;\n}());\nexports.Packer = Packer;\n/**\n * Class to unpack\n * @access private\n */\nvar Unpacker = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n     */\n    function Unpacker(disableLosslessIntegers, useBigInt) {\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\n        if (useBigInt === void 0) { useBigInt = false; }\n        this._disableLosslessIntegers = disableLosslessIntegers;\n        this._useBigInt = useBigInt;\n    }\n    Unpacker.prototype.unpack = function (buffer) {\n        var marker = buffer.readUInt8();\n        var markerHigh = marker & 0xf0;\n        var markerLow = marker & 0x0f;\n        if (marker === NULL) {\n            return null;\n        }\n        var boolean = this._unpackBoolean(marker);\n        if (boolean !== null) {\n            return boolean;\n        }\n        var numberOrInteger = this._unpackNumberOrInteger(marker, buffer);\n        if (numberOrInteger !== null) {\n            if ((0, neo4j_driver_core_1.isInt)(numberOrInteger)) {\n                if (this._useBigInt) {\n                    return numberOrInteger.toBigInt();\n                }\n                else if (this._disableLosslessIntegers) {\n                    return numberOrInteger.toNumberOrInfinity();\n                }\n            }\n            return numberOrInteger;\n        }\n        var string = this._unpackString(marker, markerHigh, markerLow, buffer);\n        if (string !== null) {\n            return string;\n        }\n        var list = this._unpackList(marker, markerHigh, markerLow, buffer);\n        if (list !== null) {\n            return list;\n        }\n        var byteArray = this._unpackByteArray(marker, buffer);\n        if (byteArray !== null) {\n            return byteArray;\n        }\n        var map = this._unpackMap(marker, markerHigh, markerLow, buffer);\n        if (map !== null) {\n            return map;\n        }\n        var struct = this._unpackStruct(marker, markerHigh, markerLow, buffer);\n        if (struct !== null) {\n            return struct;\n        }\n        throw (0, neo4j_driver_core_1.newError)('Unknown packed value with marker ' + marker.toString(16));\n    };\n    Unpacker.prototype.unpackInteger = function (buffer) {\n        var marker = buffer.readUInt8();\n        var result = this._unpackInteger(marker, buffer);\n        if (result == null) {\n            throw (0, neo4j_driver_core_1.newError)('Unable to unpack integer value with marker ' + marker.toString(16));\n        }\n        return result;\n    };\n    Unpacker.prototype._unpackBoolean = function (marker) {\n        if (marker === TRUE) {\n            return true;\n        }\n        else if (marker === FALSE) {\n            return false;\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackNumberOrInteger = function (marker, buffer) {\n        if (marker === FLOAT_64) {\n            return buffer.readFloat64();\n        }\n        else {\n            return this._unpackInteger(marker, buffer);\n        }\n    };\n    Unpacker.prototype._unpackInteger = function (marker, buffer) {\n        if (marker >= 0 && marker < 128) {\n            return (0, neo4j_driver_core_1.int)(marker);\n        }\n        else if (marker >= 240 && marker < 256) {\n            return (0, neo4j_driver_core_1.int)(marker - 256);\n        }\n        else if (marker === INT_8) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt8());\n        }\n        else if (marker === INT_16) {\n            return (0, neo4j_driver_core_1.int)(buffer.readInt16());\n        }\n        else if (marker === INT_32) {\n            var b = buffer.readInt32();\n            return (0, neo4j_driver_core_1.int)(b);\n        }\n        else if (marker === INT_64) {\n            var high = buffer.readInt32();\n            var low = buffer.readInt32();\n            return new neo4j_driver_core_1.Integer(low, high);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackString = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRING) {\n            return channel_1.utf8.decode(buffer, markerLow);\n        }\n        else if (marker === STRING_8) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt8());\n        }\n        else if (marker === STRING_16) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt16());\n        }\n        else if (marker === STRING_32) {\n            return channel_1.utf8.decode(buffer, buffer.readUInt32());\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackList = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_LIST) {\n            return this._unpackListWithSize(markerLow, buffer);\n        }\n        else if (marker === LIST_8) {\n            return this._unpackListWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === LIST_16) {\n            return this._unpackListWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === LIST_32) {\n            return this._unpackListWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackListWithSize = function (size, buffer) {\n        var value = [];\n        for (var i = 0; i < size; i++) {\n            value.push(this.unpack(buffer));\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackByteArray = function (marker, buffer) {\n        if (marker === BYTES_8) {\n            return this._unpackByteArrayWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === BYTES_16) {\n            return this._unpackByteArrayWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === BYTES_32) {\n            return this._unpackByteArrayWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackByteArrayWithSize = function (size, buffer) {\n        var value = new Int8Array(size);\n        for (var i = 0; i < size; i++) {\n            value[i] = buffer.readInt8();\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackMap = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_MAP) {\n            return this._unpackMapWithSize(markerLow, buffer);\n        }\n        else if (marker === MAP_8) {\n            return this._unpackMapWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === MAP_16) {\n            return this._unpackMapWithSize(buffer.readUInt16(), buffer);\n        }\n        else if (marker === MAP_32) {\n            return this._unpackMapWithSize(buffer.readUInt32(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackMapWithSize = function (size, buffer) {\n        var value = {};\n        for (var i = 0; i < size; i++) {\n            var key = this.unpack(buffer);\n            value[key] = this.unpack(buffer);\n        }\n        return value;\n    };\n    Unpacker.prototype._unpackStruct = function (marker, markerHigh, markerLow, buffer) {\n        if (markerHigh === TINY_STRUCT) {\n            return this._unpackStructWithSize(markerLow, buffer);\n        }\n        else if (marker === STRUCT_8) {\n            return this._unpackStructWithSize(buffer.readUInt8(), buffer);\n        }\n        else if (marker === STRUCT_16) {\n            return this._unpackStructWithSize(buffer.readUInt16(), buffer);\n        }\n        else {\n            return null;\n        }\n    };\n    Unpacker.prototype._unpackStructWithSize = function (structSize, buffer) {\n        var signature = buffer.readUInt8();\n        if (signature === NODE) {\n            return this._unpackNode(structSize, buffer);\n        }\n        else if (signature === RELATIONSHIP) {\n            return this._unpackRelationship(structSize, buffer);\n        }\n        else if (signature === UNBOUND_RELATIONSHIP) {\n            return this._unpackUnboundRelationship(structSize, buffer);\n        }\n        else if (signature === PATH) {\n            return this._unpackPath(structSize, buffer);\n        }\n        else {\n            return this._unpackUnknownStruct(signature, structSize, buffer);\n        }\n    };\n    Unpacker.prototype._unpackNode = function (structSize, buffer) {\n        this._verifyStructSize('Node', NODE_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Node(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Labels\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackRelationship = function (structSize, buffer) {\n        this._verifyStructSize('Relationship', RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.Relationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Start Node Identity\n        this.unpack(buffer), // End Node Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackUnboundRelationship = function (structSize, buffer) {\n        this._verifyStructSize('UnboundRelationship', UNBOUND_RELATIONSHIP_STRUCT_SIZE, structSize);\n        return new neo4j_driver_core_1.UnboundRelationship(this.unpack(buffer), // Identity\n        this.unpack(buffer), // Type\n        this.unpack(buffer) // Properties\n        );\n    };\n    Unpacker.prototype._unpackPath = function (structSize, buffer) {\n        this._verifyStructSize('Path', PATH_STRUCT_SIZE, structSize);\n        var nodes = this.unpack(buffer);\n        var rels = this.unpack(buffer);\n        var sequence = this.unpack(buffer);\n        var segments = [];\n        var prevNode = nodes[0];\n        for (var i = 0; i < sequence.length; i += 2) {\n            var nextNode = nodes[sequence[i + 1]];\n            var relIndex = (0, neo4j_driver_core_1.toNumber)(sequence[i]);\n            var rel = void 0;\n            if (relIndex > 0) {\n                rel = rels[relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // To avoid duplication, relationships in a path do not contain\n                    // information about their start and end nodes, that's instead\n                    // inferred from the path sequence. This is us inferring (and,\n                    // for performance reasons remembering) the start/end of a rel.\n                    rels[relIndex - 1] = rel = rel.bind(prevNode.identity, nextNode.identity);\n                }\n            }\n            else {\n                rel = rels[-relIndex - 1];\n                if (rel instanceof neo4j_driver_core_1.UnboundRelationship) {\n                    // See above\n                    rels[-relIndex - 1] = rel = rel.bind(nextNode.identity, prevNode.identity);\n                }\n            }\n            // Done hydrating one path segment.\n            segments.push(new neo4j_driver_core_1.PathSegment(prevNode, rel, nextNode));\n            prevNode = nextNode;\n        }\n        return new neo4j_driver_core_1.Path(nodes[0], nodes[nodes.length - 1], segments);\n    };\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n        var result = new Structure(signature, []);\n        for (var i = 0; i < structSize; i++) {\n            result.fields.push(this.unpack(buffer));\n        }\n        return result;\n    };\n    Unpacker.prototype._verifyStructSize = function (structName, expectedSize, actualSize) {\n        if (expectedSize !== actualSize) {\n            throw (0, neo4j_driver_core_1.newError)(\"Wrong struct size for \" + structName + \", expected \" + expectedSize + \" but was \" + actualSize, PROTOCOL_ERROR);\n        }\n    };\n    return Unpacker;\n}());\nexports.Unpacker = Unpacker;\nfunction isIterable(obj) {\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}