{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar observers_1 = require(\"./internal/observers\");\n\nvar util_1 = require(\"./internal/util\");\n\nvar error_1 = require(\"./error\");\n\nvar result_1 = __importDefault(require(\"./result\"));\n\nvar transaction_1 = __importDefault(require(\"./transaction\"));\n\nvar connection_holder_1 = require(\"./internal/connection-holder\");\n\nvar constants_1 = require(\"./internal/constants\");\n\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\n\nvar bookmark_1 = require(\"./internal/bookmark\");\n\nvar tx_config_1 = require(\"./internal/tx-config\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\n\n\nvar Session =\n/** @class */\nfunction () {\n  /**\n   * @constructor\n   * @protected\n   * @param {Object} args\n   * @param {string} args.mode the default access mode for this session.\n   * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n   * @param {Bookmark} args.bookmark - The initial bookmark for this session.\n   * @param {string} args.database the database name\n   * @param {Object} args.config={} - This driver configuration.\n   * @param {boolean} args.reactive - Whether this session should create reactive streams\n   * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n   * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n   */\n  function Session(_a) {\n    var mode = _a.mode,\n        connectionProvider = _a.connectionProvider,\n        bookmark = _a.bookmark,\n        database = _a.database,\n        config = _a.config,\n        reactive = _a.reactive,\n        fetchSize = _a.fetchSize,\n        impersonatedUser = _a.impersonatedUser;\n    this._mode = mode;\n    this._database = database;\n    this._reactive = reactive;\n    this._fetchSize = fetchSize;\n    this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n    this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_READ,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n      mode: constants_1.ACCESS_MODE_WRITE,\n      database: database,\n      bookmark: bookmark,\n      connectionProvider: connectionProvider,\n      impersonatedUser: impersonatedUser,\n      onDatabaseNameResolved: this._onDatabaseNameResolved\n    });\n    this._open = true;\n    this._hasTx = false;\n    this._impersonatedUser = impersonatedUser;\n    this._lastBookmark = bookmark || bookmark_1.Bookmark.empty();\n    this._transactionExecutor = _createTransactionExecutor(config);\n    this._onComplete = this._onCompleteCallback.bind(this);\n    this._databaseNameResolved = this._database !== '';\n  }\n  /**\n   * Run Cypher query\n   * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n   * or with the query and parameters as separate arguments.\n   *\n   * @public\n   * @param {mixed} query - Cypher query to execute\n   * @param {Object} parameters - Map with parameters to use in query\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @return {Result} New Result.\n   */\n\n\n  Session.prototype.run = function (query, parameters, transactionConfig) {\n    var _this = this;\n\n    var _a = (0, util_1.validateQueryAndParameters)(query, parameters),\n        validatedQuery = _a.validatedQuery,\n        params = _a.params;\n\n    var autoCommitTxConfig = transactionConfig ? new tx_config_1.TxConfig(transactionConfig) : tx_config_1.TxConfig.empty();\n    return this._run(validatedQuery, params, function (connection) {\n      _this._assertSessionIsOpen();\n\n      return connection.protocol().run(validatedQuery, params, {\n        bookmark: _this._lastBookmark,\n        txConfig: autoCommitTxConfig,\n        mode: _this._mode,\n        database: _this._database,\n        impersonatedUser: _this._impersonatedUser,\n        afterComplete: _this._onComplete,\n        reactive: _this._reactive,\n        fetchSize: _this._fetchSize\n      });\n    });\n  };\n\n  Session.prototype._run = function (query, parameters, customRunner) {\n    var connectionHolder = this._connectionHolderWithMode(this._mode);\n\n    var observerPromise;\n\n    if (!this._open) {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Cannot run query in a closed session.')\n      }));\n    } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n      observerPromise = connectionHolder.getConnection().then(function (connection) {\n        return customRunner(connection);\n      }).catch(function (error) {\n        return Promise.resolve(new observers_1.FailedObserver({\n          error: error\n        }));\n      });\n    } else {\n      observerPromise = Promise.resolve(new observers_1.FailedObserver({\n        error: (0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.')\n      }));\n    }\n\n    return new result_1.default(observerPromise, query, parameters, connectionHolder);\n  };\n\n  Session.prototype._acquireConnection = function (connectionConsumer) {\n    return __awaiter(this, void 0, void 0, function () {\n      var promise, connectionHolder;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        connectionHolder = this._connectionHolderWithMode(this._mode);\n\n        if (!this._open) {\n          promise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n        } else if (!this._hasTx && connectionHolder.initializeConnection()) {\n          promise = connectionHolder.getConnection().then(function (connection) {\n            return connectionConsumer(connection);\n          }).then(function (result) {\n            return __awaiter(_this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , connectionHolder.releaseConnection()];\n\n                  case 1:\n                    _a.sent();\n\n                    return [2\n                    /*return*/\n                    , result];\n                }\n              });\n            });\n          });\n        } else {\n          promise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' + 'session with an open transaction; either run from within the ' + 'transaction or use a different session.'));\n        }\n\n        return [2\n        /*return*/\n        , promise];\n      });\n    });\n  };\n  /**\n   * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n   * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n   *\n   * While a transaction is open the session cannot be used to run queries outside the transaction.\n   *\n   * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n   * @returns {Transaction} New Transaction.\n   */\n\n\n  Session.prototype.beginTransaction = function (transactionConfig) {\n    // this function needs to support bookmarks parameter for backwards compatibility\n    // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n    // that's why we need to check parameter type and decide how to interpret the value\n    var arg = transactionConfig;\n    var txConfig = tx_config_1.TxConfig.empty();\n\n    if (arg) {\n      txConfig = new tx_config_1.TxConfig(arg);\n    }\n\n    return this._beginTransaction(this._mode, txConfig);\n  };\n\n  Session.prototype._beginTransaction = function (accessMode, txConfig) {\n    if (!this._open) {\n      throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n    }\n\n    if (this._hasTx) {\n      throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' + 'either run from within the transaction or use a different session.');\n    }\n\n    var mode = Session._validateSessionMode(accessMode);\n\n    var connectionHolder = this._connectionHolderWithMode(mode);\n\n    connectionHolder.initializeConnection();\n    this._hasTx = true;\n    var tx = new transaction_1.default({\n      connectionHolder: connectionHolder,\n      impersonatedUser: this._impersonatedUser,\n      onClose: this._transactionClosed.bind(this),\n      onBookmark: this._updateBookmark.bind(this),\n      onConnection: this._assertSessionIsOpen.bind(this),\n      reactive: this._reactive,\n      fetchSize: this._fetchSize\n    });\n\n    tx._begin(this._lastBookmark, txConfig);\n\n    return tx;\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._assertSessionIsOpen = function () {\n    if (!this._open) {\n      throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n    }\n  };\n  /**\n   * @private\n   * @returns {void}\n   */\n\n\n  Session.prototype._transactionClosed = function () {\n    this._hasTx = false;\n  };\n  /**\n   * Return the bookmark received following the last completed {@link Transaction}.\n   *\n   * @return {string[]} A reference to a previous transaction.\n   */\n\n\n  Session.prototype.lastBookmark = function () {\n    return this._lastBookmark.values();\n  };\n  /**\n   * Execute given unit of work in a {@link READ} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n\n\n  Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n  };\n  /**\n   * Execute given unit of work in a {@link WRITE} transaction.\n   *\n   * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n   * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n   * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n   * `maxTransactionRetryTime` property in milliseconds.\n   *\n   * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n   * a given {@link Transaction}.\n   * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n   * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n   * function or commit fails.\n   */\n\n\n  Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n    var config = new tx_config_1.TxConfig(transactionConfig);\n    return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n  };\n\n  Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n    var _this = this;\n\n    return this._transactionExecutor.execute(function () {\n      return _this._beginTransaction(accessMode, transactionConfig);\n    }, transactionWork);\n  };\n  /**\n   * Sets the resolved database name in the session context.\n   * @private\n   * @param {string|undefined} database The resolved database name\n   * @returns {void}\n   */\n\n\n  Session.prototype._onDatabaseNameResolved = function (database) {\n    if (!this._databaseNameResolved) {\n      var normalizedDatabase = database || '';\n      this._database = normalizedDatabase;\n\n      this._readConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._writeConnectionHolder.setDatabase(normalizedDatabase);\n\n      this._databaseNameResolved = true;\n    }\n  };\n  /**\n   * Update value of the last bookmark.\n   * @private\n   * @param {Bookmark} newBookmark - The new bookmark.\n   * @returns {void}\n   */\n\n\n  Session.prototype._updateBookmark = function (newBookmark) {\n    if (newBookmark && !newBookmark.isEmpty()) {\n      this._lastBookmark = newBookmark;\n    }\n  };\n  /**\n   * Close this session.\n   * @return {Promise}\n   */\n\n\n  Session.prototype.close = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._open) return [3\n            /*break*/\n            , 3];\n            this._open = false;\n\n            this._transactionExecutor.close();\n\n            return [4\n            /*yield*/\n            , this._readConnectionHolder.close()];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._writeConnectionHolder.close()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Session.prototype._connectionHolderWithMode = function (mode) {\n    if (mode === constants_1.ACCESS_MODE_READ) {\n      return this._readConnectionHolder;\n    } else if (mode === constants_1.ACCESS_MODE_WRITE) {\n      return this._writeConnectionHolder;\n    } else {\n      throw (0, error_1.newError)('Unknown access mode: ' + mode);\n    }\n  };\n  /**\n   * @private\n   * @param {Object} meta Connection metadatada\n   * @returns {void}\n   */\n\n\n  Session.prototype._onCompleteCallback = function (meta) {\n    this._updateBookmark(new bookmark_1.Bookmark(meta.bookmark));\n  };\n  /**\n   * @protected\n   */\n\n\n  Session._validateSessionMode = function (rawMode) {\n    var mode = rawMode || constants_1.ACCESS_MODE_WRITE;\n\n    if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n      throw (0, error_1.newError)('Illegal session mode ' + mode);\n    }\n\n    return mode;\n  };\n\n  return Session;\n}();\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\n\n\nfunction _createTransactionExecutor(config) {\n  var maxRetryTimeMs = config && config.maxTransactionRetryTime ? config.maxTransactionRetryTime : null;\n  return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\n\nexports.default = Session;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","__importDefault","mod","__esModule","Object","defineProperty","exports","observers_1","require","util_1","error_1","result_1","transaction_1","connection_holder_1","constants_1","transaction_executor_1","bookmark_1","tx_config_1","Session","_a","mode","connectionProvider","bookmark","database","config","reactive","fetchSize","impersonatedUser","_mode","_database","_reactive","_fetchSize","_onDatabaseNameResolved","bind","_readConnectionHolder","ConnectionHolder","ACCESS_MODE_READ","onDatabaseNameResolved","_writeConnectionHolder","ACCESS_MODE_WRITE","_open","_hasTx","_impersonatedUser","_lastBookmark","Bookmark","empty","_transactionExecutor","_createTransactionExecutor","_onComplete","_onCompleteCallback","_databaseNameResolved","prototype","run","query","parameters","transactionConfig","_this","validateQueryAndParameters","validatedQuery","params","autoCommitTxConfig","TxConfig","_run","connection","_assertSessionIsOpen","protocol","txConfig","afterComplete","customRunner","connectionHolder","_connectionHolderWithMode","observerPromise","FailedObserver","error","newError","initializeConnection","getConnection","catch","default","_acquireConnection","connectionConsumer","promise","releaseConnection","beginTransaction","arg","_beginTransaction","accessMode","_validateSessionMode","tx","onClose","_transactionClosed","onBookmark","_updateBookmark","onConnection","_begin","lastBookmark","values","readTransaction","transactionWork","_runTransaction","writeTransaction","execute","normalizedDatabase","setDatabase","newBookmark","isEmpty","close","meta","rawMode","maxRetryTimeMs","maxTransactionRetryTime","TransactionExecutor"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-core/lib/session.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar observers_1 = require(\"./internal/observers\");\nvar util_1 = require(\"./internal/util\");\nvar error_1 = require(\"./error\");\nvar result_1 = __importDefault(require(\"./result\"));\nvar transaction_1 = __importDefault(require(\"./transaction\"));\nvar connection_holder_1 = require(\"./internal/connection-holder\");\nvar constants_1 = require(\"./internal/constants\");\nvar transaction_executor_1 = require(\"./internal/transaction-executor\");\nvar bookmark_1 = require(\"./internal/bookmark\");\nvar tx_config_1 = require(\"./internal/tx-config\");\n/**\n * A Session instance is used for handling the connection and\n * sending queries through the connection.\n * In a single session, multiple queries will be executed serially.\n * In order to execute parallel queries, multiple sessions are required.\n * @access public\n */\nvar Session = /** @class */ (function () {\n    /**\n     * @constructor\n     * @protected\n     * @param {Object} args\n     * @param {string} args.mode the default access mode for this session.\n     * @param {ConnectionProvider} args.connectionProvider - The connection provider to acquire connections from.\n     * @param {Bookmark} args.bookmark - The initial bookmark for this session.\n     * @param {string} args.database the database name\n     * @param {Object} args.config={} - This driver configuration.\n     * @param {boolean} args.reactive - Whether this session should create reactive streams\n     * @param {number} args.fetchSize - Defines how many records is pulled in each pulling batch\n     * @param {string} args.impersonatedUser - The username which the user wants to impersonate for the duration of the session.\n     */\n    function Session(_a) {\n        var mode = _a.mode, connectionProvider = _a.connectionProvider, bookmark = _a.bookmark, database = _a.database, config = _a.config, reactive = _a.reactive, fetchSize = _a.fetchSize, impersonatedUser = _a.impersonatedUser;\n        this._mode = mode;\n        this._database = database;\n        this._reactive = reactive;\n        this._fetchSize = fetchSize;\n        this._onDatabaseNameResolved = this._onDatabaseNameResolved.bind(this);\n        this._readConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_READ,\n            database: database,\n            bookmark: bookmark,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved\n        });\n        this._writeConnectionHolder = new connection_holder_1.ConnectionHolder({\n            mode: constants_1.ACCESS_MODE_WRITE,\n            database: database,\n            bookmark: bookmark,\n            connectionProvider: connectionProvider,\n            impersonatedUser: impersonatedUser,\n            onDatabaseNameResolved: this._onDatabaseNameResolved\n        });\n        this._open = true;\n        this._hasTx = false;\n        this._impersonatedUser = impersonatedUser;\n        this._lastBookmark = bookmark || bookmark_1.Bookmark.empty();\n        this._transactionExecutor = _createTransactionExecutor(config);\n        this._onComplete = this._onCompleteCallback.bind(this);\n        this._databaseNameResolved = this._database !== '';\n    }\n    /**\n     * Run Cypher query\n     * Could be called with a query object i.e.: `{text: \"MATCH ...\", parameters: {param: 1}}`\n     * or with the query and parameters as separate arguments.\n     *\n     * @public\n     * @param {mixed} query - Cypher query to execute\n     * @param {Object} parameters - Map with parameters to use in query\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @return {Result} New Result.\n     */\n    Session.prototype.run = function (query, parameters, transactionConfig) {\n        var _this = this;\n        var _a = (0, util_1.validateQueryAndParameters)(query, parameters), validatedQuery = _a.validatedQuery, params = _a.params;\n        var autoCommitTxConfig = transactionConfig\n            ? new tx_config_1.TxConfig(transactionConfig)\n            : tx_config_1.TxConfig.empty();\n        return this._run(validatedQuery, params, function (connection) {\n            _this._assertSessionIsOpen();\n            return connection.protocol().run(validatedQuery, params, {\n                bookmark: _this._lastBookmark,\n                txConfig: autoCommitTxConfig,\n                mode: _this._mode,\n                database: _this._database,\n                impersonatedUser: _this._impersonatedUser,\n                afterComplete: _this._onComplete,\n                reactive: _this._reactive,\n                fetchSize: _this._fetchSize\n            });\n        });\n    };\n    Session.prototype._run = function (query, parameters, customRunner) {\n        var connectionHolder = this._connectionHolderWithMode(this._mode);\n        var observerPromise;\n        if (!this._open) {\n            observerPromise = Promise.resolve(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Cannot run query in a closed session.')\n            }));\n        }\n        else if (!this._hasTx && connectionHolder.initializeConnection()) {\n            observerPromise = connectionHolder\n                .getConnection()\n                .then(function (connection) { return customRunner(connection); })\n                .catch(function (error) { return Promise.resolve(new observers_1.FailedObserver({ error: error })); });\n        }\n        else {\n            observerPromise = Promise.resolve(new observers_1.FailedObserver({\n                error: (0, error_1.newError)('Queries cannot be run directly on a ' +\n                    'session with an open transaction; either run from within the ' +\n                    'transaction or use a different session.')\n            }));\n        }\n        return new result_1.default(observerPromise, query, parameters, connectionHolder);\n    };\n    Session.prototype._acquireConnection = function (connectionConsumer) {\n        return __awaiter(this, void 0, void 0, function () {\n            var promise, connectionHolder;\n            var _this = this;\n            return __generator(this, function (_a) {\n                connectionHolder = this._connectionHolderWithMode(this._mode);\n                if (!this._open) {\n                    promise = Promise.reject((0, error_1.newError)('Cannot run query in a closed session.'));\n                }\n                else if (!this._hasTx && connectionHolder.initializeConnection()) {\n                    promise = connectionHolder\n                        .getConnection()\n                        .then(function (connection) { return connectionConsumer(connection); })\n                        .then(function (result) { return __awaiter(_this, void 0, void 0, function () {\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0: return [4 /*yield*/, connectionHolder.releaseConnection()];\n                                case 1:\n                                    _a.sent();\n                                    return [2 /*return*/, result];\n                            }\n                        });\n                    }); });\n                }\n                else {\n                    promise = Promise.reject((0, error_1.newError)('Queries cannot be run directly on a ' +\n                        'session with an open transaction; either run from within the ' +\n                        'transaction or use a different session.'));\n                }\n                return [2 /*return*/, promise];\n            });\n        });\n    };\n    /**\n     * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you\n     * want to run multiple concurrent transactions, you should use multiple concurrent sessions.\n     *\n     * While a transaction is open the session cannot be used to run queries outside the transaction.\n     *\n     * @param {TransactionConfig} [transactionConfig] - Configuration for the new auto-commit transaction.\n     * @returns {Transaction} New Transaction.\n     */\n    Session.prototype.beginTransaction = function (transactionConfig) {\n        // this function needs to support bookmarks parameter for backwards compatibility\n        // parameter was of type {string|string[]} and represented either a single or multiple bookmarks\n        // that's why we need to check parameter type and decide how to interpret the value\n        var arg = transactionConfig;\n        var txConfig = tx_config_1.TxConfig.empty();\n        if (arg) {\n            txConfig = new tx_config_1.TxConfig(arg);\n        }\n        return this._beginTransaction(this._mode, txConfig);\n    };\n    Session.prototype._beginTransaction = function (accessMode, txConfig) {\n        if (!this._open) {\n            throw (0, error_1.newError)('Cannot begin a transaction on a closed session.');\n        }\n        if (this._hasTx) {\n            throw (0, error_1.newError)('You cannot begin a transaction on a session with an open transaction; ' +\n                'either run from within the transaction or use a different session.');\n        }\n        var mode = Session._validateSessionMode(accessMode);\n        var connectionHolder = this._connectionHolderWithMode(mode);\n        connectionHolder.initializeConnection();\n        this._hasTx = true;\n        var tx = new transaction_1.default({\n            connectionHolder: connectionHolder,\n            impersonatedUser: this._impersonatedUser,\n            onClose: this._transactionClosed.bind(this),\n            onBookmark: this._updateBookmark.bind(this),\n            onConnection: this._assertSessionIsOpen.bind(this),\n            reactive: this._reactive,\n            fetchSize: this._fetchSize\n        });\n        tx._begin(this._lastBookmark, txConfig);\n        return tx;\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._assertSessionIsOpen = function () {\n        if (!this._open) {\n            throw (0, error_1.newError)('You cannot run more transactions on a closed session.');\n        }\n    };\n    /**\n     * @private\n     * @returns {void}\n     */\n    Session.prototype._transactionClosed = function () {\n        this._hasTx = false;\n    };\n    /**\n     * Return the bookmark received following the last completed {@link Transaction}.\n     *\n     * @return {string[]} A reference to a previous transaction.\n     */\n    Session.prototype.lastBookmark = function () {\n        return this._lastBookmark.values();\n    };\n    /**\n     * Execute given unit of work in a {@link READ} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.readTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig);\n        return this._runTransaction(constants_1.ACCESS_MODE_READ, config, transactionWork);\n    };\n    /**\n     * Execute given unit of work in a {@link WRITE} transaction.\n     *\n     * Transaction will automatically be committed unless the given function throws or returns a rejected promise.\n     * Some failures of the given function or the commit itself will be retried with exponential backoff with initial\n     * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's\n     * `maxTransactionRetryTime` property in milliseconds.\n     *\n     * @param {function(tx: Transaction): Promise} transactionWork - Callback that executes operations against\n     * a given {@link Transaction}.\n     * @param {TransactionConfig} [transactionConfig] - Configuration for all transactions started to execute the unit of work.\n     * @return {Promise} Resolved promise as returned by the given function or rejected promise when given\n     * function or commit fails.\n     */\n    Session.prototype.writeTransaction = function (transactionWork, transactionConfig) {\n        var config = new tx_config_1.TxConfig(transactionConfig);\n        return this._runTransaction(constants_1.ACCESS_MODE_WRITE, config, transactionWork);\n    };\n    Session.prototype._runTransaction = function (accessMode, transactionConfig, transactionWork) {\n        var _this = this;\n        return this._transactionExecutor.execute(function () { return _this._beginTransaction(accessMode, transactionConfig); }, transactionWork);\n    };\n    /**\n     * Sets the resolved database name in the session context.\n     * @private\n     * @param {string|undefined} database The resolved database name\n     * @returns {void}\n     */\n    Session.prototype._onDatabaseNameResolved = function (database) {\n        if (!this._databaseNameResolved) {\n            var normalizedDatabase = database || '';\n            this._database = normalizedDatabase;\n            this._readConnectionHolder.setDatabase(normalizedDatabase);\n            this._writeConnectionHolder.setDatabase(normalizedDatabase);\n            this._databaseNameResolved = true;\n        }\n    };\n    /**\n     * Update value of the last bookmark.\n     * @private\n     * @param {Bookmark} newBookmark - The new bookmark.\n     * @returns {void}\n     */\n    Session.prototype._updateBookmark = function (newBookmark) {\n        if (newBookmark && !newBookmark.isEmpty()) {\n            this._lastBookmark = newBookmark;\n        }\n    };\n    /**\n     * Close this session.\n     * @return {Promise}\n     */\n    Session.prototype.close = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._open) return [3 /*break*/, 3];\n                        this._open = false;\n                        this._transactionExecutor.close();\n                        return [4 /*yield*/, this._readConnectionHolder.close()];\n                    case 1:\n                        _a.sent();\n                        return [4 /*yield*/, this._writeConnectionHolder.close()];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    Session.prototype._connectionHolderWithMode = function (mode) {\n        if (mode === constants_1.ACCESS_MODE_READ) {\n            return this._readConnectionHolder;\n        }\n        else if (mode === constants_1.ACCESS_MODE_WRITE) {\n            return this._writeConnectionHolder;\n        }\n        else {\n            throw (0, error_1.newError)('Unknown access mode: ' + mode);\n        }\n    };\n    /**\n     * @private\n     * @param {Object} meta Connection metadatada\n     * @returns {void}\n     */\n    Session.prototype._onCompleteCallback = function (meta) {\n        this._updateBookmark(new bookmark_1.Bookmark(meta.bookmark));\n    };\n    /**\n     * @protected\n     */\n    Session._validateSessionMode = function (rawMode) {\n        var mode = rawMode || constants_1.ACCESS_MODE_WRITE;\n        if (mode !== constants_1.ACCESS_MODE_READ && mode !== constants_1.ACCESS_MODE_WRITE) {\n            throw (0, error_1.newError)('Illegal session mode ' + mode);\n        }\n        return mode;\n    };\n    return Session;\n}());\n/**\n * @private\n * @param {object} config\n * @returns {TransactionExecutor} The transaction executor\n */\nfunction _createTransactionExecutor(config) {\n    var maxRetryTimeMs = config && config.maxTransactionRetryTime\n        ? config.maxTransactionRetryTime\n        : null;\n    return new transaction_executor_1.TransactionExecutor(maxRetryTimeMs);\n}\nexports.default = Session;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}