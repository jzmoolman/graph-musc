{"ast":null,"code":"/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\"; // math-inlining.\n\nconst {\n  abs,\n  min,\n  max,\n  cos,\n  sin,\n  acos,\n  sqrt\n} = Math;\nconst pi = Math.PI; // a zero coordinate, which is surprisingly useful\n\nconst ZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    const points = this.points = [];\n\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length; // is this curve, practically speaking, a straight line?\n\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    const abc = Bezier.getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n    const e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n          e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n          A = abc.A,\n          v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n          v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n          nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n          nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC() {\n    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    let S = arguments.length > 1 ? arguments[1] : undefined;\n    let B = arguments.length > 2 ? arguments[2] : undefined;\n    let E = arguments.length > 3 ? arguments[3] : undefined;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    const u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n          s = utils.abcratio(t, order),\n          A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = []; // n steps means n+1 points\n\n    steps++;\n    this._lut = [];\n\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n\n      this._lut.push(p);\n    }\n\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n          hits = [];\n\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n    let mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n    mdist += 1;\n\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return {\n      t,\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2; // cross product\n\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m; // rotation matrix\n\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n    while (p.length > 1) {\n      _p = [];\n\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n\n        _p.push(pt);\n      }\n\n      p = _p;\n    }\n\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n\n    if (t2 === 1) {\n      return this.split(t1).right;\n    } // no shortcut: use \"de Casteljau\" iteration.\n\n\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    }; // make sure we bind _t1/_t2 information!\n\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n    if (!t2) {\n      return result;\n    } // if we have a t2, split again:\n\n\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n          result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n          tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n            n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n\n      return ret;\n    }\n\n    if (this._linear) {\n      const nv = this.normal(0),\n            coords = this.points.map(function (p) {\n        const ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n\n        if (p.z && nv.z) {\n          ret.z = p.z + t * nv.z;\n        }\n\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n    let extrema = this.extrema().values;\n\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    } // second pass: further reduce these segments to simple segments\n\n\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n\n          if (!segment.simple()) {\n            t2 -= step;\n\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1; // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);\n    return new Bezier(this.points.map((p, i) => ({\n      x: p.x + v.x * d[i],\n      y: p.y + v.y * d[i]\n    })));\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    } // TODO: add special handling for non-linear degenerate curves.\n\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    } // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n\n\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    } // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n\n\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = {\n        x: start.x + n.x * d1,\n        y: start.y + n.y * d1\n      };\n      e = {\n        x: end.x + n.x * d3,\n        y: end.y + n.y * d3\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const fline = [s, mid, e];\n      s = {\n        x: start.x - n.x * d2,\n        y: start.y - n.y * d2\n      };\n      e = {\n        x: end.x - n.x * d4,\n        y: end.y - n.y * d4\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const bline = [e, mid, s];\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n    let bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    } // form curve oulines\n\n\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n\n      alen += slen;\n    }); // reverse the \"return\" outline\n\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n\n      return s;\n    }).reverse(); // form the endcaps as lines\n\n    const fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    const reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = []; // step 1: pair off any overlapping segments\n\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    }); // step 2: for each pairing, run through the convergence algorithm.\n\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n    do {\n      safety = 0; // step 1: start with the maximum possible arc\n\n      t_e = 1; // points:\n\n      let np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc; // booleans:\n\n      let curr_good = false,\n          prev_good = false,\n          done; // numbers:\n\n      let t_m = t_e,\n          prev_e = 1,\n          step = 0; // step 2: find the best possible arc\n\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n\n            break;\n          } // if not, move it up by half the iteration distance\n\n\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    return circles;\n  }\n\n}\n\nexport { Bezier };","map":{"version":3,"names":["utils","PolyBezier","abs","min","max","cos","sin","acos","sqrt","Math","pi","PI","ZERO","x","y","z","Bezier","constructor","coords","args","forEach","Array","from","arguments","slice","coordlen","length","newargs","point","d","push","higher","len","Error","_3d","points","idx","step","order","dims","dimlen","aligned","align","p1","p2","baselength","dist","_linear","reduce","t","p","_lut","_t1","_t2","update","quadraticFromPoints","p3","abc","getABC","A","cubicFromPoints","S","B","E","d1","C","d2","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","v1","v2","nc1","nc2","getUtils","valueOf","toString","pointsToString","toSVG","s","i","last","join","setRatios","ratios","verify","print","coordDigest","_print","map","c","pos","dpoints","derive","computedirection","angle","clockwise","derivative","bind","u","projectionratio","um","abcratio","get","getLUT","steps","compute","on","error","lut","hits","project","LUT","l","closest","mpos","t1","t2","mdist","ft","computeWithRatios","raise","np","k","pim","dderivative","curvature","inflections","normal","__normal3","__normal2","q","r1","r2","q1","q2","m","R","n","hull","_p","pt","lerp","split","left","right","result","span","extrema","roots","dim","mfn","v","droots","concat","filter","sort","numberSort","values","indexOf","bbox","getminmax","overlaps","curve","lbbox","tbbox","bboxoverlap","offset","ret","nv","scale","simple","a1","a2","n1","n2","segment","pass1","pass2","translate","o","_","distanceFn","lli4","copy","ov","rc","outline","d3","d4","undefined","start","end","mid","e","fline","bline","ls","makeline","le","segments","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","f1","f2","reverse","fs","fe","bs","be","outlineshapes","curveIntersectionThreshold","curves","shapes","shape","makeshape","startcap","virtual","endcap","intersects","selfintersects","lineIntersects","curveintersects","line","mx","my","MX","MY","between","results","c1","c2","pairs","r","intersections","pair","pairiteration","arcs","errorThreshold","_iterate","_error","pc","np1","ref","circles","t_s","t_e","safety","np2","np3","arc","prev_arc","curr_good","prev_good","done","t_m","prev_e","getccenter","interval"],"sources":["/Users/zack/src/_-MUSC/gene-graph-MUSC/node_modules/bezier-js/src/bezier.js"],"sourcesContent":["/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}