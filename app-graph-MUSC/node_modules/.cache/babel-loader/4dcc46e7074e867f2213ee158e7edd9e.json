{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\n\nvar integer_1 = __importStar(require(\"../integer\"));\n\nvar error_1 = require(\"../error\");\n\nvar util_1 = require(\"./util\");\n/*\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\n\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\n\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\n  conversion functions.\n */\n\n\nvar ValueRange =\n/** @class */\nfunction () {\n  function ValueRange(min, max) {\n    this._minNumber = min;\n    this._maxNumber = max;\n    this._minInteger = (0, integer_1.int)(min);\n    this._maxInteger = (0, integer_1.int)(max);\n  }\n\n  ValueRange.prototype.contains = function (value) {\n    if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n      return value.greaterThanOrEqual(this._minInteger) && value.lessThanOrEqual(this._maxInteger);\n    } else if (typeof value === 'bigint') {\n      var intValue = (0, integer_1.int)(value);\n      return intValue.greaterThanOrEqual(this._minInteger) && intValue.lessThanOrEqual(this._maxInteger);\n    } else {\n      return value >= this._minNumber && value <= this._maxNumber;\n    }\n  };\n\n  ValueRange.prototype.toString = function () {\n    return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\n  };\n\n  return ValueRange;\n}();\n\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\n\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n  return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\n\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\n\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n  return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\n\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\n * @param {Integer|number|string} hour the hour of the local time to convert.\n * @param {Integer|number|string} minute the minute of the local time to convert.\n * @param {Integer|number|string} second the second of the local time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\n * @return {Integer} nanoseconds representing the given local time.\n */\n\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  nanosecond = (0, integer_1.int)(nanosecond);\n  var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n  totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n  totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n  return totalNanos.add(nanosecond);\n}\n\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\n * @param {Integer|number|string} year the year of the local date-time to convert.\n * @param {Integer|number|string} month the month of the local date-time to convert.\n * @param {Integer|number|string} day the day of the local date-time to convert.\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\n * @param {Integer|number|string} second the second of the local date-time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\n * @return {Integer} epoch second in UTC representing the given local date time.\n */\n\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n  var epochDay = dateToEpochDay(year, month, day);\n  var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n  return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\n\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\n * Converts given local date into a single integer representing it's epoch day.\n * @param {Integer|number|string} year the year of the local date to convert.\n * @param {Integer|number|string} month the month of the local date to convert.\n * @param {Integer|number|string} day the day of the local date to convert.\n * @return {Integer} epoch day representing the given date.\n */\n\nfunction dateToEpochDay(year, month, day) {\n  year = (0, integer_1.int)(year);\n  month = (0, integer_1.int)(month);\n  day = (0, integer_1.int)(day);\n  var epochDay = year.multiply(365);\n\n  if (year.greaterThanOrEqual(0)) {\n    epochDay = epochDay.add(year.add(3).div(4).subtract(year.add(99).div(100)).add(year.add(399).div(400)));\n  } else {\n    epochDay = epochDay.subtract(year.div(-4).subtract(year.div(-100)).add(year.div(-400)));\n  }\n\n  epochDay = epochDay.add(month.multiply(367).subtract(362).div(12));\n  epochDay = epochDay.add(day.subtract(1));\n\n  if (month.greaterThan(2)) {\n    epochDay = epochDay.subtract(1);\n\n    if (!isLeapYear(year)) {\n      epochDay = epochDay.subtract(1);\n    }\n  }\n\n  return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\n\nexports.dateToEpochDay = dateToEpochDay;\n/**\n * Format given duration to an ISO 8601 string.\n * @param {Integer|number|string} months the number of months.\n * @param {Integer|number|string} days the number of days.\n * @param {Integer|number|string} seconds the number of seconds.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\n * @return {string} ISO string that represents given duration.\n */\n\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n  var monthsString = formatNumber(months);\n  var daysString = formatNumber(days);\n  var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n  return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\n}\n\nexports.durationToIsoString = durationToIsoString;\n/**\n * Formats given time to an ISO 8601 string.\n * @param {Integer|number|string} hour the hour value.\n * @param {Integer|number|string} minute the minute value.\n * @param {Integer|number|string} second the second value.\n * @param {Integer|number|string} nanosecond the nanosecond value.\n * @return {string} ISO string that represents given time.\n */\n\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n  var hourString = formatNumber(hour, 2);\n  var minuteString = formatNumber(minute, 2);\n  var secondString = formatNumber(second, 2);\n  var nanosecondString = formatNanosecond(nanosecond);\n  return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\n}\n\nexports.timeToIsoString = timeToIsoString;\n/**\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\n * @return {string} ISO string that represents given offset.\n */\n\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n  offsetSeconds = (0, integer_1.int)(offsetSeconds);\n\n  if (offsetSeconds.equals(0)) {\n    return 'Z';\n  }\n\n  var isNegative = offsetSeconds.isNegative();\n\n  if (isNegative) {\n    offsetSeconds = offsetSeconds.multiply(-1);\n  }\n\n  var signPrefix = isNegative ? '-' : '+';\n  var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n  var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n  var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n  var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n  return seconds ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds : \"\" + signPrefix + hours + \":\" + minutes;\n}\n\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\n * Formats given date to an ISO 8601 string.\n * @param {Integer|number|string} year the date year.\n * @param {Integer|number|string} month the date month.\n * @param {Integer|number|string} day the date day.\n * @return {string} ISO string that represents given date.\n */\n\nfunction dateToIsoString(year, month, day) {\n  year = (0, integer_1.int)(year);\n  var isNegative = year.isNegative();\n\n  if (isNegative) {\n    year = year.multiply(-1);\n  }\n\n  var yearString = formatNumber(year, 4);\n\n  if (isNegative) {\n    yearString = '-' + yearString;\n  }\n\n  var monthString = formatNumber(month, 2);\n  var dayString = formatNumber(day, 2);\n  return yearString + \"-\" + monthString + \"-\" + dayString;\n}\n\nexports.dateToIsoString = dateToIsoString;\n/**\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\n * @param {global.Date} standardDate the standard JavaScript date.\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\n * @return {Integer|number|bigint} the total amount of nanoseconds.\n */\n\nfunction totalNanoseconds(standardDate, nanoseconds) {\n  nanoseconds = nanoseconds || 0;\n  var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n  return add(nanoseconds, nanosFromMillis);\n}\n\nexports.totalNanoseconds = totalNanoseconds;\n/**\n * Get the time zone offset in seconds from the given standard JavaScript date.\n *\n * <b>Implementation note:</b>\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\n * So positive value means offset is behind UTC and negative value means it is ahead.\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\n *\n * @param {global.Date} standardDate the standard JavaScript date.\n * @return {number} the time zone offset in seconds.\n */\n\nfunction timeZoneOffsetInSeconds(standardDate) {\n  var offsetInMinutes = standardDate.getTimezoneOffset();\n\n  if (offsetInMinutes === 0) {\n    return 0;\n  }\n\n  return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\n}\n\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\n * Assert that the year value is valid.\n * @param {Integer|number} year the value to check.\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidYear(year) {\n  return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\n\nexports.assertValidYear = assertValidYear;\n/**\n * Assert that the month value is valid.\n * @param {Integer|number} month the value to check.\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidMonth(month) {\n  return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\n\nexports.assertValidMonth = assertValidMonth;\n/**\n * Assert that the day value is valid.\n * @param {Integer|number} day the value to check.\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidDay(day) {\n  return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\n\nexports.assertValidDay = assertValidDay;\n/**\n * Assert that the hour value is valid.\n * @param {Integer|number} hour the value to check.\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidHour(hour) {\n  return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\n\nexports.assertValidHour = assertValidHour;\n/**\n * Assert that the minute value is valid.\n * @param {Integer|number} minute the value to check.\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidMinute(minute) {\n  return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\n\nexports.assertValidMinute = assertValidMinute;\n/**\n * Assert that the second value is valid.\n * @param {Integer|number} second the value to check.\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidSecond(second) {\n  return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\n\nexports.assertValidSecond = assertValidSecond;\n/**\n * Assert that the nanosecond value is valid.\n * @param {Integer|number} nanosecond the value to check.\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\n */\n\nfunction assertValidNanosecond(nanosecond) {\n  return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\n\nexports.assertValidNanosecond = assertValidNanosecond;\n/**\n * Check if the given value is of expected type and is in the expected range.\n * @param {Integer|number} value the value to check.\n * @param {ValueRange} range the range.\n * @param {string} name the name of the value.\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\n */\n\nfunction assertValidTemporalValue(value, range, name) {\n  (0, util_1.assertNumberOrInteger)(value, name);\n\n  if (!range.contains(value)) {\n    throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\n  }\n\n  return value;\n}\n/**\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\n * @param {Integer|number|string} hour the hour of the local time.\n * @param {Integer|number|string} minute the minute of the local time.\n * @param {Integer|number|string} second the second of the local time.\n * @return {Integer} seconds representing the given local time.\n */\n\n\nfunction localTimeToSecondOfDay(hour, minute, second) {\n  hour = (0, integer_1.int)(hour);\n  minute = (0, integer_1.int)(minute);\n  second = (0, integer_1.int)(second);\n  var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n  totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n  return totalSeconds.add(second);\n}\n/**\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\n */\n\n\nfunction isLeapYear(year) {\n  year = (0, integer_1.int)(year);\n\n  if (!year.modulo(4).equals(0)) {\n    return false;\n  } else if (!year.modulo(100).equals(0)) {\n    return true;\n  } else if (!year.modulo(400).equals(0)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\n\n\nfunction floorDiv(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  var result = x.div(y);\n\n  if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n    result = result.subtract(1);\n  }\n\n  return result;\n}\n\nexports.floorDiv = floorDiv;\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\n\nfunction floorMod(x, y) {\n  x = (0, integer_1.int)(x);\n  y = (0, integer_1.int)(y);\n  return x.subtract(floorDiv(x, y).multiply(y));\n}\n\nexports.floorMod = floorMod;\n/**\n * @param {Integer|number|string} seconds the number of seconds to format.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\n * @return {string} formatted value.\n */\n\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n  seconds = (0, integer_1.int)(seconds);\n  nanoseconds = (0, integer_1.int)(nanoseconds);\n  var secondsString;\n  var nanosecondsString;\n  var secondsNegative = seconds.isNegative();\n  var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n\n  if (secondsNegative && nanosecondsGreaterThanZero) {\n    if (seconds.equals(-1)) {\n      secondsString = '-0';\n    } else {\n      secondsString = seconds.add(1).toString();\n    }\n  } else {\n    secondsString = seconds.toString();\n  }\n\n  if (nanosecondsGreaterThanZero) {\n    if (secondsNegative) {\n      nanosecondsString = formatNanosecond(nanoseconds.negate().add(2 * exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    } else {\n      nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n    }\n  }\n\n  return nanosecondsString ? secondsString + nanosecondsString : secondsString;\n}\n/**\n * @param {Integer|number|string} value the number of nanoseconds to format.\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\n */\n\n\nfunction formatNanosecond(value) {\n  value = (0, integer_1.int)(value);\n  return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\n * @param {Integer|number|string} num the number to format.\n * @param {number} [stringLength=undefined] the string length to left-pad to.\n * @return {string} formatted and possibly left-padded number as string.\n */\n\n\nfunction formatNumber(num, stringLength) {\n  num = (0, integer_1.int)(num);\n  var isNegative = num.isNegative();\n\n  if (isNegative) {\n    num = num.negate();\n  }\n\n  var numString = num.toString();\n\n  if (stringLength) {\n    // left pad the string with zeroes\n    while (numString.length < stringLength) {\n      numString = '0' + numString;\n    }\n  }\n\n  return isNegative ? '-' + numString : numString;\n}\n\nfunction add(x, y) {\n  if (x instanceof integer_1.default) {\n    return x.add(y);\n  } else if (typeof x === 'bigint') {\n    return x + BigInt(y);\n  }\n\n  return x + y;\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","exports","floorMod","floorDiv","assertValidNanosecond","assertValidSecond","assertValidMinute","assertValidHour","assertValidDay","assertValidMonth","assertValidYear","timeZoneOffsetInSeconds","totalNanoseconds","dateToIsoString","timeZoneOffsetToIsoString","timeToIsoString","durationToIsoString","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","normalizeNanosecondsForDuration","normalizeSecondsForDuration","SECONDS_PER_DAY","DAYS_PER_400_YEAR_CYCLE","DAYS_0000_TO_1970","NANOS_PER_HOUR","NANOS_PER_MINUTE","NANOS_PER_MILLISECOND","NANOS_PER_SECOND","SECONDS_PER_HOUR","SECONDS_PER_MINUTE","MINUTES_PER_HOUR","NANOSECOND_OF_SECOND_RANGE","SECOND_OF_MINUTE_RANGE","MINUTE_OF_HOUR_RANGE","HOUR_OF_DAY_RANGE","DAY_OF_MONTH_RANGE","MONTH_OF_YEAR_RANGE","YEAR_RANGE","integer_1","require","error_1","util_1","ValueRange","min","max","_minNumber","_maxNumber","_minInteger","int","_maxInteger","contains","isInt","default","greaterThanOrEqual","lessThanOrEqual","intValue","toString","seconds","nanoseconds","add","hour","minute","second","nanosecond","totalNanos","multiply","year","month","day","epochDay","localTimeSeconds","localTimeToSecondOfDay","div","subtract","greaterThan","isLeapYear","months","days","monthsString","formatNumber","daysString","secondsAndNanosecondsString","formatSecondsAndNanosecondsForDuration","hourString","minuteString","secondString","nanosecondString","formatNanosecond","offsetSeconds","equals","isNegative","signPrefix","hours","minutes","modulo","secondsValue","yearString","monthString","dayString","standardDate","nanosFromMillis","getMilliseconds","offsetInMinutes","getTimezoneOffset","assertValidTemporalValue","range","name","assertNumberOrInteger","newError","totalSeconds","x","y","isPositive","notEquals","secondsString","nanosecondsString","secondsNegative","nanosecondsGreaterThanZero","negate","num","stringLength","numString","length","BigInt"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-core/lib/internal/temporal-util.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.floorMod = exports.floorDiv = exports.assertValidNanosecond = exports.assertValidSecond = exports.assertValidMinute = exports.assertValidHour = exports.assertValidDay = exports.assertValidMonth = exports.assertValidYear = exports.timeZoneOffsetInSeconds = exports.totalNanoseconds = exports.dateToIsoString = exports.timeZoneOffsetToIsoString = exports.timeToIsoString = exports.durationToIsoString = exports.dateToEpochDay = exports.localDateTimeToEpochSecond = exports.localTimeToNanoOfDay = exports.normalizeNanosecondsForDuration = exports.normalizeSecondsForDuration = exports.SECONDS_PER_DAY = exports.DAYS_PER_400_YEAR_CYCLE = exports.DAYS_0000_TO_1970 = exports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE = exports.NANOS_PER_MILLISECOND = exports.NANOS_PER_SECOND = exports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE = exports.MINUTES_PER_HOUR = exports.NANOSECOND_OF_SECOND_RANGE = exports.SECOND_OF_MINUTE_RANGE = exports.MINUTE_OF_HOUR_RANGE = exports.HOUR_OF_DAY_RANGE = exports.DAY_OF_MONTH_RANGE = exports.MONTH_OF_YEAR_RANGE = exports.YEAR_RANGE = void 0;\nvar integer_1 = __importStar(require(\"../integer\"));\nvar error_1 = require(\"../error\");\nvar util_1 = require(\"./util\");\n/*\n  Code in this util should be compatible with code in the database that uses JSR-310 java.time APIs.\n\n  It is based on a library called ThreeTen (https://github.com/ThreeTen/threetenbp) which was derived\n  from JSR-310 reference implementation previously hosted on GitHub. Code uses `Integer` type everywhere\n  to correctly handle large integer values that are greater than `Number.MAX_SAFE_INTEGER`.\n\n  Please consult either ThreeTen or js-joda (https://github.com/js-joda/js-joda) when working with the\n  conversion functions.\n */\nvar ValueRange = /** @class */ (function () {\n    function ValueRange(min, max) {\n        this._minNumber = min;\n        this._maxNumber = max;\n        this._minInteger = (0, integer_1.int)(min);\n        this._maxInteger = (0, integer_1.int)(max);\n    }\n    ValueRange.prototype.contains = function (value) {\n        if ((0, integer_1.isInt)(value) && value instanceof integer_1.default) {\n            return (value.greaterThanOrEqual(this._minInteger) &&\n                value.lessThanOrEqual(this._maxInteger));\n        }\n        else if (typeof value === 'bigint') {\n            var intValue = (0, integer_1.int)(value);\n            return (intValue.greaterThanOrEqual(this._minInteger) &&\n                intValue.lessThanOrEqual(this._maxInteger));\n        }\n        else {\n            return value >= this._minNumber && value <= this._maxNumber;\n        }\n    };\n    ValueRange.prototype.toString = function () {\n        return \"[\" + this._minNumber + \", \" + this._maxNumber + \"]\";\n    };\n    return ValueRange;\n}());\nexports.YEAR_RANGE = new ValueRange(-999999999, 999999999);\nexports.MONTH_OF_YEAR_RANGE = new ValueRange(1, 12);\nexports.DAY_OF_MONTH_RANGE = new ValueRange(1, 31);\nexports.HOUR_OF_DAY_RANGE = new ValueRange(0, 23);\nexports.MINUTE_OF_HOUR_RANGE = new ValueRange(0, 59);\nexports.SECOND_OF_MINUTE_RANGE = new ValueRange(0, 59);\nexports.NANOSECOND_OF_SECOND_RANGE = new ValueRange(0, 999999999);\nexports.MINUTES_PER_HOUR = 60;\nexports.SECONDS_PER_MINUTE = 60;\nexports.SECONDS_PER_HOUR = exports.SECONDS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.NANOS_PER_SECOND = 1000000000;\nexports.NANOS_PER_MILLISECOND = 1000000;\nexports.NANOS_PER_MINUTE = exports.NANOS_PER_SECOND * exports.SECONDS_PER_MINUTE;\nexports.NANOS_PER_HOUR = exports.NANOS_PER_MINUTE * exports.MINUTES_PER_HOUR;\nexports.DAYS_0000_TO_1970 = 719528;\nexports.DAYS_PER_400_YEAR_CYCLE = 146097;\nexports.SECONDS_PER_DAY = 86400;\nfunction normalizeSecondsForDuration(seconds, nanoseconds) {\n    return (0, integer_1.int)(seconds).add(floorDiv(nanoseconds, exports.NANOS_PER_SECOND));\n}\nexports.normalizeSecondsForDuration = normalizeSecondsForDuration;\nfunction normalizeNanosecondsForDuration(nanoseconds) {\n    return floorMod(nanoseconds, exports.NANOS_PER_SECOND);\n}\nexports.normalizeNanosecondsForDuration = normalizeNanosecondsForDuration;\n/**\n * Converts given local time into a single integer representing this same time in nanoseconds of the day.\n * @param {Integer|number|string} hour the hour of the local time to convert.\n * @param {Integer|number|string} minute the minute of the local time to convert.\n * @param {Integer|number|string} second the second of the local time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local time to convert.\n * @return {Integer} nanoseconds representing the given local time.\n */\nfunction localTimeToNanoOfDay(hour, minute, second, nanosecond) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    nanosecond = (0, integer_1.int)(nanosecond);\n    var totalNanos = hour.multiply(exports.NANOS_PER_HOUR);\n    totalNanos = totalNanos.add(minute.multiply(exports.NANOS_PER_MINUTE));\n    totalNanos = totalNanos.add(second.multiply(exports.NANOS_PER_SECOND));\n    return totalNanos.add(nanosecond);\n}\nexports.localTimeToNanoOfDay = localTimeToNanoOfDay;\n/**\n * Converts given local date time into a single integer representing this same time in epoch seconds UTC.\n * @param {Integer|number|string} year the year of the local date-time to convert.\n * @param {Integer|number|string} month the month of the local date-time to convert.\n * @param {Integer|number|string} day the day of the local date-time to convert.\n * @param {Integer|number|string} hour the hour of the local date-time to convert.\n * @param {Integer|number|string} minute the minute of the local date-time to convert.\n * @param {Integer|number|string} second the second of the local date-time to convert.\n * @param {Integer|number|string} nanosecond the nanosecond of the local date-time to convert.\n * @return {Integer} epoch second in UTC representing the given local date time.\n */\nfunction localDateTimeToEpochSecond(year, month, day, hour, minute, second, nanosecond) {\n    var epochDay = dateToEpochDay(year, month, day);\n    var localTimeSeconds = localTimeToSecondOfDay(hour, minute, second);\n    return epochDay.multiply(exports.SECONDS_PER_DAY).add(localTimeSeconds);\n}\nexports.localDateTimeToEpochSecond = localDateTimeToEpochSecond;\n/**\n * Converts given local date into a single integer representing it's epoch day.\n * @param {Integer|number|string} year the year of the local date to convert.\n * @param {Integer|number|string} month the month of the local date to convert.\n * @param {Integer|number|string} day the day of the local date to convert.\n * @return {Integer} epoch day representing the given date.\n */\nfunction dateToEpochDay(year, month, day) {\n    year = (0, integer_1.int)(year);\n    month = (0, integer_1.int)(month);\n    day = (0, integer_1.int)(day);\n    var epochDay = year.multiply(365);\n    if (year.greaterThanOrEqual(0)) {\n        epochDay = epochDay.add(year\n            .add(3)\n            .div(4)\n            .subtract(year.add(99).div(100))\n            .add(year.add(399).div(400)));\n    }\n    else {\n        epochDay = epochDay.subtract(year\n            .div(-4)\n            .subtract(year.div(-100))\n            .add(year.div(-400)));\n    }\n    epochDay = epochDay.add(month\n        .multiply(367)\n        .subtract(362)\n        .div(12));\n    epochDay = epochDay.add(day.subtract(1));\n    if (month.greaterThan(2)) {\n        epochDay = epochDay.subtract(1);\n        if (!isLeapYear(year)) {\n            epochDay = epochDay.subtract(1);\n        }\n    }\n    return epochDay.subtract(exports.DAYS_0000_TO_1970);\n}\nexports.dateToEpochDay = dateToEpochDay;\n/**\n * Format given duration to an ISO 8601 string.\n * @param {Integer|number|string} months the number of months.\n * @param {Integer|number|string} days the number of days.\n * @param {Integer|number|string} seconds the number of seconds.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds.\n * @return {string} ISO string that represents given duration.\n */\nfunction durationToIsoString(months, days, seconds, nanoseconds) {\n    var monthsString = formatNumber(months);\n    var daysString = formatNumber(days);\n    var secondsAndNanosecondsString = formatSecondsAndNanosecondsForDuration(seconds, nanoseconds);\n    return \"P\" + monthsString + \"M\" + daysString + \"DT\" + secondsAndNanosecondsString + \"S\";\n}\nexports.durationToIsoString = durationToIsoString;\n/**\n * Formats given time to an ISO 8601 string.\n * @param {Integer|number|string} hour the hour value.\n * @param {Integer|number|string} minute the minute value.\n * @param {Integer|number|string} second the second value.\n * @param {Integer|number|string} nanosecond the nanosecond value.\n * @return {string} ISO string that represents given time.\n */\nfunction timeToIsoString(hour, minute, second, nanosecond) {\n    var hourString = formatNumber(hour, 2);\n    var minuteString = formatNumber(minute, 2);\n    var secondString = formatNumber(second, 2);\n    var nanosecondString = formatNanosecond(nanosecond);\n    return hourString + \":\" + minuteString + \":\" + secondString + nanosecondString;\n}\nexports.timeToIsoString = timeToIsoString;\n/**\n * Formats given time zone offset in seconds to string representation like '±HH:MM', '±HH:MM:SS' or 'Z' for UTC.\n * @param {Integer|number|string} offsetSeconds the offset in seconds.\n * @return {string} ISO string that represents given offset.\n */\nfunction timeZoneOffsetToIsoString(offsetSeconds) {\n    offsetSeconds = (0, integer_1.int)(offsetSeconds);\n    if (offsetSeconds.equals(0)) {\n        return 'Z';\n    }\n    var isNegative = offsetSeconds.isNegative();\n    if (isNegative) {\n        offsetSeconds = offsetSeconds.multiply(-1);\n    }\n    var signPrefix = isNegative ? '-' : '+';\n    var hours = formatNumber(offsetSeconds.div(exports.SECONDS_PER_HOUR), 2);\n    var minutes = formatNumber(offsetSeconds.div(exports.SECONDS_PER_MINUTE).modulo(exports.MINUTES_PER_HOUR), 2);\n    var secondsValue = offsetSeconds.modulo(exports.SECONDS_PER_MINUTE);\n    var seconds = secondsValue.equals(0) ? null : formatNumber(secondsValue, 2);\n    return seconds\n        ? \"\" + signPrefix + hours + \":\" + minutes + \":\" + seconds\n        : \"\" + signPrefix + hours + \":\" + minutes;\n}\nexports.timeZoneOffsetToIsoString = timeZoneOffsetToIsoString;\n/**\n * Formats given date to an ISO 8601 string.\n * @param {Integer|number|string} year the date year.\n * @param {Integer|number|string} month the date month.\n * @param {Integer|number|string} day the date day.\n * @return {string} ISO string that represents given date.\n */\nfunction dateToIsoString(year, month, day) {\n    year = (0, integer_1.int)(year);\n    var isNegative = year.isNegative();\n    if (isNegative) {\n        year = year.multiply(-1);\n    }\n    var yearString = formatNumber(year, 4);\n    if (isNegative) {\n        yearString = '-' + yearString;\n    }\n    var monthString = formatNumber(month, 2);\n    var dayString = formatNumber(day, 2);\n    return yearString + \"-\" + monthString + \"-\" + dayString;\n}\nexports.dateToIsoString = dateToIsoString;\n/**\n * Get the total number of nanoseconds from the milliseconds of the given standard JavaScript date and optional nanosecond part.\n * @param {global.Date} standardDate the standard JavaScript date.\n * @param {Integer|number|bigint|undefined} nanoseconds the optional number of nanoseconds.\n * @return {Integer|number|bigint} the total amount of nanoseconds.\n */\nfunction totalNanoseconds(standardDate, nanoseconds) {\n    nanoseconds = nanoseconds || 0;\n    var nanosFromMillis = standardDate.getMilliseconds() * exports.NANOS_PER_MILLISECOND;\n    return add(nanoseconds, nanosFromMillis);\n}\nexports.totalNanoseconds = totalNanoseconds;\n/**\n * Get the time zone offset in seconds from the given standard JavaScript date.\n *\n * <b>Implementation note:</b>\n * Time zone offset returned by the standard JavaScript date is the difference, in minutes, from local time to UTC.\n * So positive value means offset is behind UTC and negative value means it is ahead.\n * For Neo4j temporal types, like `Time` or `DateTime` offset is in seconds and represents difference from UTC to local time.\n * This is different from standard JavaScript dates and that's why implementation negates the returned value.\n *\n * @param {global.Date} standardDate the standard JavaScript date.\n * @return {number} the time zone offset in seconds.\n */\nfunction timeZoneOffsetInSeconds(standardDate) {\n    var offsetInMinutes = standardDate.getTimezoneOffset();\n    if (offsetInMinutes === 0) {\n        return 0;\n    }\n    return -1 * offsetInMinutes * exports.SECONDS_PER_MINUTE;\n}\nexports.timeZoneOffsetInSeconds = timeZoneOffsetInSeconds;\n/**\n * Assert that the year value is valid.\n * @param {Integer|number} year the value to check.\n * @return {Integer|number} the value of the year if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidYear(year) {\n    return assertValidTemporalValue(year, exports.YEAR_RANGE, 'Year');\n}\nexports.assertValidYear = assertValidYear;\n/**\n * Assert that the month value is valid.\n * @param {Integer|number} month the value to check.\n * @return {Integer|number} the value of the month if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMonth(month) {\n    return assertValidTemporalValue(month, exports.MONTH_OF_YEAR_RANGE, 'Month');\n}\nexports.assertValidMonth = assertValidMonth;\n/**\n * Assert that the day value is valid.\n * @param {Integer|number} day the value to check.\n * @return {Integer|number} the value of the day if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidDay(day) {\n    return assertValidTemporalValue(day, exports.DAY_OF_MONTH_RANGE, 'Day');\n}\nexports.assertValidDay = assertValidDay;\n/**\n * Assert that the hour value is valid.\n * @param {Integer|number} hour the value to check.\n * @return {Integer|number} the value of the hour if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidHour(hour) {\n    return assertValidTemporalValue(hour, exports.HOUR_OF_DAY_RANGE, 'Hour');\n}\nexports.assertValidHour = assertValidHour;\n/**\n * Assert that the minute value is valid.\n * @param {Integer|number} minute the value to check.\n * @return {Integer|number} the value of the minute if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidMinute(minute) {\n    return assertValidTemporalValue(minute, exports.MINUTE_OF_HOUR_RANGE, 'Minute');\n}\nexports.assertValidMinute = assertValidMinute;\n/**\n * Assert that the second value is valid.\n * @param {Integer|number} second the value to check.\n * @return {Integer|number} the value of the second if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidSecond(second) {\n    return assertValidTemporalValue(second, exports.SECOND_OF_MINUTE_RANGE, 'Second');\n}\nexports.assertValidSecond = assertValidSecond;\n/**\n * Assert that the nanosecond value is valid.\n * @param {Integer|number} nanosecond the value to check.\n * @return {Integer|number} the value of the nanosecond if it is valid. Exception is thrown otherwise.\n */\nfunction assertValidNanosecond(nanosecond) {\n    return assertValidTemporalValue(nanosecond, exports.NANOSECOND_OF_SECOND_RANGE, 'Nanosecond');\n}\nexports.assertValidNanosecond = assertValidNanosecond;\n/**\n * Check if the given value is of expected type and is in the expected range.\n * @param {Integer|number} value the value to check.\n * @param {ValueRange} range the range.\n * @param {string} name the name of the value.\n * @return {Integer|number} the value if valid. Exception is thrown otherwise.\n */\nfunction assertValidTemporalValue(value, range, name) {\n    (0, util_1.assertNumberOrInteger)(value, name);\n    if (!range.contains(value)) {\n        throw (0, error_1.newError)(name + \" is expected to be in range \" + range + \" but was: \" + value);\n    }\n    return value;\n}\n/**\n * Converts given local time into a single integer representing this same time in seconds of the day. Nanoseconds are skipped.\n * @param {Integer|number|string} hour the hour of the local time.\n * @param {Integer|number|string} minute the minute of the local time.\n * @param {Integer|number|string} second the second of the local time.\n * @return {Integer} seconds representing the given local time.\n */\nfunction localTimeToSecondOfDay(hour, minute, second) {\n    hour = (0, integer_1.int)(hour);\n    minute = (0, integer_1.int)(minute);\n    second = (0, integer_1.int)(second);\n    var totalSeconds = hour.multiply(exports.SECONDS_PER_HOUR);\n    totalSeconds = totalSeconds.add(minute.multiply(exports.SECONDS_PER_MINUTE));\n    return totalSeconds.add(second);\n}\n/**\n * Check if given year is a leap year. Uses algorithm described here {@link https://en.wikipedia.org/wiki/Leap_year#Algorithm}.\n * @param {Integer|number|string} year the year to check. Will be converted to {@link Integer} for all calculations.\n * @return {boolean} `true` if given year is a leap year, `false` otherwise.\n */\nfunction isLeapYear(year) {\n    year = (0, integer_1.int)(year);\n    if (!year.modulo(4).equals(0)) {\n        return false;\n    }\n    else if (!year.modulo(100).equals(0)) {\n        return true;\n    }\n    else if (!year.modulo(400).equals(0)) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorDiv(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    var result = x.div(y);\n    if (x.isPositive() !== y.isPositive() && result.multiply(y).notEquals(x)) {\n        result = result.subtract(1);\n    }\n    return result;\n}\nexports.floorDiv = floorDiv;\n/**\n * @param {Integer|number|string} x the divident.\n * @param {Integer|number|string} y the divisor.\n * @return {Integer} the result.\n */\nfunction floorMod(x, y) {\n    x = (0, integer_1.int)(x);\n    y = (0, integer_1.int)(y);\n    return x.subtract(floorDiv(x, y).multiply(y));\n}\nexports.floorMod = floorMod;\n/**\n * @param {Integer|number|string} seconds the number of seconds to format.\n * @param {Integer|number|string} nanoseconds the number of nanoseconds to format.\n * @return {string} formatted value.\n */\nfunction formatSecondsAndNanosecondsForDuration(seconds, nanoseconds) {\n    seconds = (0, integer_1.int)(seconds);\n    nanoseconds = (0, integer_1.int)(nanoseconds);\n    var secondsString;\n    var nanosecondsString;\n    var secondsNegative = seconds.isNegative();\n    var nanosecondsGreaterThanZero = nanoseconds.greaterThan(0);\n    if (secondsNegative && nanosecondsGreaterThanZero) {\n        if (seconds.equals(-1)) {\n            secondsString = '-0';\n        }\n        else {\n            secondsString = seconds.add(1).toString();\n        }\n    }\n    else {\n        secondsString = seconds.toString();\n    }\n    if (nanosecondsGreaterThanZero) {\n        if (secondsNegative) {\n            nanosecondsString = formatNanosecond(nanoseconds\n                .negate()\n                .add(2 * exports.NANOS_PER_SECOND)\n                .modulo(exports.NANOS_PER_SECOND));\n        }\n        else {\n            nanosecondsString = formatNanosecond(nanoseconds.add(exports.NANOS_PER_SECOND).modulo(exports.NANOS_PER_SECOND));\n        }\n    }\n    return nanosecondsString ? secondsString + nanosecondsString : secondsString;\n}\n/**\n * @param {Integer|number|string} value the number of nanoseconds to format.\n * @return {string} formatted and possibly left-padded nanoseconds part as string.\n */\nfunction formatNanosecond(value) {\n    value = (0, integer_1.int)(value);\n    return value.equals(0) ? '' : '.' + formatNumber(value, 9);\n}\n/**\n * @param {Integer|number|string} num the number to format.\n * @param {number} [stringLength=undefined] the string length to left-pad to.\n * @return {string} formatted and possibly left-padded number as string.\n */\nfunction formatNumber(num, stringLength) {\n    num = (0, integer_1.int)(num);\n    var isNegative = num.isNegative();\n    if (isNegative) {\n        num = num.negate();\n    }\n    var numString = num.toString();\n    if (stringLength) {\n        // left pad the string with zeroes\n        while (numString.length < stringLength) {\n            numString = '0' + numString;\n        }\n    }\n    return isNegative ? '-' + numString : numString;\n}\nfunction add(x, y) {\n    if (x instanceof integer_1.default) {\n        return x.add(y);\n    }\n    else if (typeof x === 'bigint') {\n        return x + BigInt(y);\n    }\n    return x + y;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,KAAmCC,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;EAC5F,IAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;EACtBJ,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyBG,EAAzB,EAA6B;IAAEG,UAAU,EAAE,IAAd;IAAoBC,GAAG,EAAE,YAAW;MAAE,OAAON,CAAC,CAACC,CAAD,CAAR;IAAc;EAApD,CAA7B;AACH,CAHwD,GAGnD,UAASF,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;EACxB,IAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;EACtBF,CAAC,CAACG,EAAD,CAAD,GAAQF,CAAC,CAACC,CAAD,CAAT;AACH,CANqB,CAAtB;;AAOA,IAAIM,kBAAkB,GAAI,QAAQ,KAAKA,kBAAd,KAAsCV,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYS,CAAZ,EAAe;EAC3FX,MAAM,CAACO,cAAP,CAAsBL,CAAtB,EAAyB,SAAzB,EAAoC;IAAEM,UAAU,EAAE,IAAd;IAAoBI,KAAK,EAAED;EAA3B,CAApC;AACH,CAF8D,GAE1D,UAAST,CAAT,EAAYS,CAAZ,EAAe;EAChBT,CAAC,CAAC,SAAD,CAAD,GAAeS,CAAf;AACH,CAJwB,CAAzB;;AAKA,IAAIE,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;EAC7D,IAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B,OAAOD,GAAP;EAC3B,IAAIE,MAAM,GAAG,EAAb;EACA,IAAIF,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIV,CAAT,IAAcU,GAAd,EAAmB,IAAIV,CAAC,KAAK,SAAN,IAAmBJ,MAAM,CAACiB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,GAArC,EAA0CV,CAA1C,CAAvB,EAAqEL,eAAe,CAACiB,MAAD,EAASF,GAAT,EAAcV,CAAd,CAAf;;EACzGM,kBAAkB,CAACM,MAAD,EAASF,GAAT,CAAlB;;EACA,OAAOE,MAAP;AACH,CAND;;AAOAhB,MAAM,CAACO,cAAP,CAAsBa,OAAtB,EAA+B,YAA/B,EAA6C;EAAER,KAAK,EAAE;AAAT,CAA7C;AACAQ,OAAO,CAACC,QAAR,GAAmBD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,qBAAR,GAAgCH,OAAO,CAACI,iBAAR,GAA4BJ,OAAO,CAACK,iBAAR,GAA4BL,OAAO,CAACM,eAAR,GAA0BN,OAAO,CAACO,cAAR,GAAyBP,OAAO,CAACQ,gBAAR,GAA2BR,OAAO,CAACS,eAAR,GAA0BT,OAAO,CAACU,uBAAR,GAAkCV,OAAO,CAACW,gBAAR,GAA2BX,OAAO,CAACY,eAAR,GAA0BZ,OAAO,CAACa,yBAAR,GAAoCb,OAAO,CAACc,eAAR,GAA0Bd,OAAO,CAACe,mBAAR,GAA8Bf,OAAO,CAACgB,cAAR,GAAyBhB,OAAO,CAACiB,0BAAR,GAAqCjB,OAAO,CAACkB,oBAAR,GAA+BlB,OAAO,CAACmB,+BAAR,GAA0CnB,OAAO,CAACoB,2BAAR,GAAsCpB,OAAO,CAACqB,eAAR,GAA0BrB,OAAO,CAACsB,uBAAR,GAAkCtB,OAAO,CAACuB,iBAAR,GAA4BvB,OAAO,CAACwB,cAAR,GAAyBxB,OAAO,CAACyB,gBAAR,GAA2BzB,OAAO,CAAC0B,qBAAR,GAAgC1B,OAAO,CAAC2B,gBAAR,GAA2B3B,OAAO,CAAC4B,gBAAR,GAA2B5B,OAAO,CAAC6B,kBAAR,GAA6B7B,OAAO,CAAC8B,gBAAR,GAA2B9B,OAAO,CAAC+B,0BAAR,GAAqC/B,OAAO,CAACgC,sBAAR,GAAiChC,OAAO,CAACiC,oBAAR,GAA+BjC,OAAO,CAACkC,iBAAR,GAA4BlC,OAAO,CAACmC,kBAAR,GAA6BnC,OAAO,CAACoC,mBAAR,GAA8BpC,OAAO,CAACqC,UAAR,GAAqB,KAAK,CAAtjC;;AACA,IAAIC,SAAS,GAAG7C,YAAY,CAAC8C,OAAO,CAAC,YAAD,CAAR,CAA5B;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,QAAD,CAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIG,UAAU;AAAG;AAAe,YAAY;EACxC,SAASA,UAAT,CAAoBC,GAApB,EAAyBC,GAAzB,EAA8B;IAC1B,KAAKC,UAAL,GAAkBF,GAAlB;IACA,KAAKG,UAAL,GAAkBF,GAAlB;IACA,KAAKG,WAAL,GAAmB,CAAC,GAAGT,SAAS,CAACU,GAAd,EAAmBL,GAAnB,CAAnB;IACA,KAAKM,WAAL,GAAmB,CAAC,GAAGX,SAAS,CAACU,GAAd,EAAmBJ,GAAnB,CAAnB;EACH;;EACDF,UAAU,CAAC7C,SAAX,CAAqBqD,QAArB,GAAgC,UAAU1D,KAAV,EAAiB;IAC7C,IAAI,CAAC,GAAG8C,SAAS,CAACa,KAAd,EAAqB3D,KAArB,KAA+BA,KAAK,YAAY8C,SAAS,CAACc,OAA9D,EAAuE;MACnE,OAAQ5D,KAAK,CAAC6D,kBAAN,CAAyB,KAAKN,WAA9B,KACJvD,KAAK,CAAC8D,eAAN,CAAsB,KAAKL,WAA3B,CADJ;IAEH,CAHD,MAIK,IAAI,OAAOzD,KAAP,KAAiB,QAArB,EAA+B;MAChC,IAAI+D,QAAQ,GAAG,CAAC,GAAGjB,SAAS,CAACU,GAAd,EAAmBxD,KAAnB,CAAf;MACA,OAAQ+D,QAAQ,CAACF,kBAAT,CAA4B,KAAKN,WAAjC,KACJQ,QAAQ,CAACD,eAAT,CAAyB,KAAKL,WAA9B,CADJ;IAEH,CAJI,MAKA;MACD,OAAOzD,KAAK,IAAI,KAAKqD,UAAd,IAA4BrD,KAAK,IAAI,KAAKsD,UAAjD;IACH;EACJ,CAbD;;EAcAJ,UAAU,CAAC7C,SAAX,CAAqB2D,QAArB,GAAgC,YAAY;IACxC,OAAO,MAAM,KAAKX,UAAX,GAAwB,IAAxB,GAA+B,KAAKC,UAApC,GAAiD,GAAxD;EACH,CAFD;;EAGA,OAAOJ,UAAP;AACH,CAzB+B,EAAhC;;AA0BA1C,OAAO,CAACqC,UAAR,GAAqB,IAAIK,UAAJ,CAAe,CAAC,SAAhB,EAA2B,SAA3B,CAArB;AACA1C,OAAO,CAACoC,mBAAR,GAA8B,IAAIM,UAAJ,CAAe,CAAf,EAAkB,EAAlB,CAA9B;AACA1C,OAAO,CAACmC,kBAAR,GAA6B,IAAIO,UAAJ,CAAe,CAAf,EAAkB,EAAlB,CAA7B;AACA1C,OAAO,CAACkC,iBAAR,GAA4B,IAAIQ,UAAJ,CAAe,CAAf,EAAkB,EAAlB,CAA5B;AACA1C,OAAO,CAACiC,oBAAR,GAA+B,IAAIS,UAAJ,CAAe,CAAf,EAAkB,EAAlB,CAA/B;AACA1C,OAAO,CAACgC,sBAAR,GAAiC,IAAIU,UAAJ,CAAe,CAAf,EAAkB,EAAlB,CAAjC;AACA1C,OAAO,CAAC+B,0BAAR,GAAqC,IAAIW,UAAJ,CAAe,CAAf,EAAkB,SAAlB,CAArC;AACA1C,OAAO,CAAC8B,gBAAR,GAA2B,EAA3B;AACA9B,OAAO,CAAC6B,kBAAR,GAA6B,EAA7B;AACA7B,OAAO,CAAC4B,gBAAR,GAA2B5B,OAAO,CAAC6B,kBAAR,GAA6B7B,OAAO,CAAC8B,gBAAhE;AACA9B,OAAO,CAAC2B,gBAAR,GAA2B,UAA3B;AACA3B,OAAO,CAAC0B,qBAAR,GAAgC,OAAhC;AACA1B,OAAO,CAACyB,gBAAR,GAA2BzB,OAAO,CAAC2B,gBAAR,GAA2B3B,OAAO,CAAC6B,kBAA9D;AACA7B,OAAO,CAACwB,cAAR,GAAyBxB,OAAO,CAACyB,gBAAR,GAA2BzB,OAAO,CAAC8B,gBAA5D;AACA9B,OAAO,CAACuB,iBAAR,GAA4B,MAA5B;AACAvB,OAAO,CAACsB,uBAAR,GAAkC,MAAlC;AACAtB,OAAO,CAACqB,eAAR,GAA0B,KAA1B;;AACA,SAASD,2BAAT,CAAqCqC,OAArC,EAA8CC,WAA9C,EAA2D;EACvD,OAAO,CAAC,GAAGpB,SAAS,CAACU,GAAd,EAAmBS,OAAnB,EAA4BE,GAA5B,CAAgCzD,QAAQ,CAACwD,WAAD,EAAc1D,OAAO,CAAC2B,gBAAtB,CAAxC,CAAP;AACH;;AACD3B,OAAO,CAACoB,2BAAR,GAAsCA,2BAAtC;;AACA,SAASD,+BAAT,CAAyCuC,WAAzC,EAAsD;EAClD,OAAOzD,QAAQ,CAACyD,WAAD,EAAc1D,OAAO,CAAC2B,gBAAtB,CAAf;AACH;;AACD3B,OAAO,CAACmB,+BAAR,GAA0CA,+BAA1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,oBAAT,CAA8B0C,IAA9B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,UAApD,EAAgE;EAC5DH,IAAI,GAAG,CAAC,GAAGtB,SAAS,CAACU,GAAd,EAAmBY,IAAnB,CAAP;EACAC,MAAM,GAAG,CAAC,GAAGvB,SAAS,CAACU,GAAd,EAAmBa,MAAnB,CAAT;EACAC,MAAM,GAAG,CAAC,GAAGxB,SAAS,CAACU,GAAd,EAAmBc,MAAnB,CAAT;EACAC,UAAU,GAAG,CAAC,GAAGzB,SAAS,CAACU,GAAd,EAAmBe,UAAnB,CAAb;EACA,IAAIC,UAAU,GAAGJ,IAAI,CAACK,QAAL,CAAcjE,OAAO,CAACwB,cAAtB,CAAjB;EACAwC,UAAU,GAAGA,UAAU,CAACL,GAAX,CAAeE,MAAM,CAACI,QAAP,CAAgBjE,OAAO,CAACyB,gBAAxB,CAAf,CAAb;EACAuC,UAAU,GAAGA,UAAU,CAACL,GAAX,CAAeG,MAAM,CAACG,QAAP,CAAgBjE,OAAO,CAAC2B,gBAAxB,CAAf,CAAb;EACA,OAAOqC,UAAU,CAACL,GAAX,CAAeI,UAAf,CAAP;AACH;;AACD/D,OAAO,CAACkB,oBAAR,GAA+BA,oBAA/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,0BAAT,CAAoCiD,IAApC,EAA0CC,KAA1C,EAAiDC,GAAjD,EAAsDR,IAAtD,EAA4DC,MAA5D,EAAoEC,MAApE,EAA4EC,UAA5E,EAAwF;EACpF,IAAIM,QAAQ,GAAGrD,cAAc,CAACkD,IAAD,EAAOC,KAAP,EAAcC,GAAd,CAA7B;EACA,IAAIE,gBAAgB,GAAGC,sBAAsB,CAACX,IAAD,EAAOC,MAAP,EAAeC,MAAf,CAA7C;EACA,OAAOO,QAAQ,CAACJ,QAAT,CAAkBjE,OAAO,CAACqB,eAA1B,EAA2CsC,GAA3C,CAA+CW,gBAA/C,CAAP;AACH;;AACDtE,OAAO,CAACiB,0BAAR,GAAqCA,0BAArC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,cAAT,CAAwBkD,IAAxB,EAA8BC,KAA9B,EAAqCC,GAArC,EAA0C;EACtCF,IAAI,GAAG,CAAC,GAAG5B,SAAS,CAACU,GAAd,EAAmBkB,IAAnB,CAAP;EACAC,KAAK,GAAG,CAAC,GAAG7B,SAAS,CAACU,GAAd,EAAmBmB,KAAnB,CAAR;EACAC,GAAG,GAAG,CAAC,GAAG9B,SAAS,CAACU,GAAd,EAAmBoB,GAAnB,CAAN;EACA,IAAIC,QAAQ,GAAGH,IAAI,CAACD,QAAL,CAAc,GAAd,CAAf;;EACA,IAAIC,IAAI,CAACb,kBAAL,CAAwB,CAAxB,CAAJ,EAAgC;IAC5BgB,QAAQ,GAAGA,QAAQ,CAACV,GAAT,CAAaO,IAAI,CACvBP,GADmB,CACf,CADe,EAEnBa,GAFmB,CAEf,CAFe,EAGnBC,QAHmB,CAGVP,IAAI,CAACP,GAAL,CAAS,EAAT,EAAaa,GAAb,CAAiB,GAAjB,CAHU,EAInBb,GAJmB,CAIfO,IAAI,CAACP,GAAL,CAAS,GAAT,EAAca,GAAd,CAAkB,GAAlB,CAJe,CAAb,CAAX;EAKH,CAND,MAOK;IACDH,QAAQ,GAAGA,QAAQ,CAACI,QAAT,CAAkBP,IAAI,CAC5BM,GADwB,CACpB,CAAC,CADmB,EAExBC,QAFwB,CAEfP,IAAI,CAACM,GAAL,CAAS,CAAC,GAAV,CAFe,EAGxBb,GAHwB,CAGpBO,IAAI,CAACM,GAAL,CAAS,CAAC,GAAV,CAHoB,CAAlB,CAAX;EAIH;;EACDH,QAAQ,GAAGA,QAAQ,CAACV,GAAT,CAAaQ,KAAK,CACxBF,QADmB,CACV,GADU,EAEnBQ,QAFmB,CAEV,GAFU,EAGnBD,GAHmB,CAGf,EAHe,CAAb,CAAX;EAIAH,QAAQ,GAAGA,QAAQ,CAACV,GAAT,CAAaS,GAAG,CAACK,QAAJ,CAAa,CAAb,CAAb,CAAX;;EACA,IAAIN,KAAK,CAACO,WAAN,CAAkB,CAAlB,CAAJ,EAA0B;IACtBL,QAAQ,GAAGA,QAAQ,CAACI,QAAT,CAAkB,CAAlB,CAAX;;IACA,IAAI,CAACE,UAAU,CAACT,IAAD,CAAf,EAAuB;MACnBG,QAAQ,GAAGA,QAAQ,CAACI,QAAT,CAAkB,CAAlB,CAAX;IACH;EACJ;;EACD,OAAOJ,QAAQ,CAACI,QAAT,CAAkBzE,OAAO,CAACuB,iBAA1B,CAAP;AACH;;AACDvB,OAAO,CAACgB,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,mBAAT,CAA6B6D,MAA7B,EAAqCC,IAArC,EAA2CpB,OAA3C,EAAoDC,WAApD,EAAiE;EAC7D,IAAIoB,YAAY,GAAGC,YAAY,CAACH,MAAD,CAA/B;EACA,IAAII,UAAU,GAAGD,YAAY,CAACF,IAAD,CAA7B;EACA,IAAII,2BAA2B,GAAGC,sCAAsC,CAACzB,OAAD,EAAUC,WAAV,CAAxE;EACA,OAAO,MAAMoB,YAAN,GAAqB,GAArB,GAA2BE,UAA3B,GAAwC,IAAxC,GAA+CC,2BAA/C,GAA6E,GAApF;AACH;;AACDjF,OAAO,CAACe,mBAAR,GAA8BA,mBAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,eAAT,CAAyB8C,IAAzB,EAA+BC,MAA/B,EAAuCC,MAAvC,EAA+CC,UAA/C,EAA2D;EACvD,IAAIoB,UAAU,GAAGJ,YAAY,CAACnB,IAAD,EAAO,CAAP,CAA7B;EACA,IAAIwB,YAAY,GAAGL,YAAY,CAAClB,MAAD,EAAS,CAAT,CAA/B;EACA,IAAIwB,YAAY,GAAGN,YAAY,CAACjB,MAAD,EAAS,CAAT,CAA/B;EACA,IAAIwB,gBAAgB,GAAGC,gBAAgB,CAACxB,UAAD,CAAvC;EACA,OAAOoB,UAAU,GAAG,GAAb,GAAmBC,YAAnB,GAAkC,GAAlC,GAAwCC,YAAxC,GAAuDC,gBAA9D;AACH;;AACDtF,OAAO,CAACc,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,yBAAT,CAAmC2E,aAAnC,EAAkD;EAC9CA,aAAa,GAAG,CAAC,GAAGlD,SAAS,CAACU,GAAd,EAAmBwC,aAAnB,CAAhB;;EACA,IAAIA,aAAa,CAACC,MAAd,CAAqB,CAArB,CAAJ,EAA6B;IACzB,OAAO,GAAP;EACH;;EACD,IAAIC,UAAU,GAAGF,aAAa,CAACE,UAAd,EAAjB;;EACA,IAAIA,UAAJ,EAAgB;IACZF,aAAa,GAAGA,aAAa,CAACvB,QAAd,CAAuB,CAAC,CAAxB,CAAhB;EACH;;EACD,IAAI0B,UAAU,GAAGD,UAAU,GAAG,GAAH,GAAS,GAApC;EACA,IAAIE,KAAK,GAAGb,YAAY,CAACS,aAAa,CAAChB,GAAd,CAAkBxE,OAAO,CAAC4B,gBAA1B,CAAD,EAA8C,CAA9C,CAAxB;EACA,IAAIiE,OAAO,GAAGd,YAAY,CAACS,aAAa,CAAChB,GAAd,CAAkBxE,OAAO,CAAC6B,kBAA1B,EAA8CiE,MAA9C,CAAqD9F,OAAO,CAAC8B,gBAA7D,CAAD,EAAiF,CAAjF,CAA1B;EACA,IAAIiE,YAAY,GAAGP,aAAa,CAACM,MAAd,CAAqB9F,OAAO,CAAC6B,kBAA7B,CAAnB;EACA,IAAI4B,OAAO,GAAGsC,YAAY,CAACN,MAAb,CAAoB,CAApB,IAAyB,IAAzB,GAAgCV,YAAY,CAACgB,YAAD,EAAe,CAAf,CAA1D;EACA,OAAOtC,OAAO,GACR,KAAKkC,UAAL,GAAkBC,KAAlB,GAA0B,GAA1B,GAAgCC,OAAhC,GAA0C,GAA1C,GAAgDpC,OADxC,GAER,KAAKkC,UAAL,GAAkBC,KAAlB,GAA0B,GAA1B,GAAgCC,OAFtC;AAGH;;AACD7F,OAAO,CAACa,yBAAR,GAAoCA,yBAApC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,eAAT,CAAyBsD,IAAzB,EAA+BC,KAA/B,EAAsCC,GAAtC,EAA2C;EACvCF,IAAI,GAAG,CAAC,GAAG5B,SAAS,CAACU,GAAd,EAAmBkB,IAAnB,CAAP;EACA,IAAIwB,UAAU,GAAGxB,IAAI,CAACwB,UAAL,EAAjB;;EACA,IAAIA,UAAJ,EAAgB;IACZxB,IAAI,GAAGA,IAAI,CAACD,QAAL,CAAc,CAAC,CAAf,CAAP;EACH;;EACD,IAAI+B,UAAU,GAAGjB,YAAY,CAACb,IAAD,EAAO,CAAP,CAA7B;;EACA,IAAIwB,UAAJ,EAAgB;IACZM,UAAU,GAAG,MAAMA,UAAnB;EACH;;EACD,IAAIC,WAAW,GAAGlB,YAAY,CAACZ,KAAD,EAAQ,CAAR,CAA9B;EACA,IAAI+B,SAAS,GAAGnB,YAAY,CAACX,GAAD,EAAM,CAAN,CAA5B;EACA,OAAO4B,UAAU,GAAG,GAAb,GAAmBC,WAAnB,GAAiC,GAAjC,GAAuCC,SAA9C;AACH;;AACDlG,OAAO,CAACY,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,gBAAT,CAA0BwF,YAA1B,EAAwCzC,WAAxC,EAAqD;EACjDA,WAAW,GAAGA,WAAW,IAAI,CAA7B;EACA,IAAI0C,eAAe,GAAGD,YAAY,CAACE,eAAb,KAAiCrG,OAAO,CAAC0B,qBAA/D;EACA,OAAOiC,GAAG,CAACD,WAAD,EAAc0C,eAAd,CAAV;AACH;;AACDpG,OAAO,CAACW,gBAAR,GAA2BA,gBAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,uBAAT,CAAiCyF,YAAjC,EAA+C;EAC3C,IAAIG,eAAe,GAAGH,YAAY,CAACI,iBAAb,EAAtB;;EACA,IAAID,eAAe,KAAK,CAAxB,EAA2B;IACvB,OAAO,CAAP;EACH;;EACD,OAAO,CAAC,CAAD,GAAKA,eAAL,GAAuBtG,OAAO,CAAC6B,kBAAtC;AACH;;AACD7B,OAAO,CAACU,uBAAR,GAAkCA,uBAAlC;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,eAAT,CAAyByD,IAAzB,EAA+B;EAC3B,OAAOsC,wBAAwB,CAACtC,IAAD,EAAOlE,OAAO,CAACqC,UAAf,EAA2B,MAA3B,CAA/B;AACH;;AACDrC,OAAO,CAACS,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,gBAAT,CAA0B2D,KAA1B,EAAiC;EAC7B,OAAOqC,wBAAwB,CAACrC,KAAD,EAAQnE,OAAO,CAACoC,mBAAhB,EAAqC,OAArC,CAA/B;AACH;;AACDpC,OAAO,CAACQ,gBAAR,GAA2BA,gBAA3B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,cAAT,CAAwB6D,GAAxB,EAA6B;EACzB,OAAOoC,wBAAwB,CAACpC,GAAD,EAAMpE,OAAO,CAACmC,kBAAd,EAAkC,KAAlC,CAA/B;AACH;;AACDnC,OAAO,CAACO,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,eAAT,CAAyBsD,IAAzB,EAA+B;EAC3B,OAAO4C,wBAAwB,CAAC5C,IAAD,EAAO5D,OAAO,CAACkC,iBAAf,EAAkC,MAAlC,CAA/B;AACH;;AACDlC,OAAO,CAACM,eAAR,GAA0BA,eAA1B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,iBAAT,CAA2BwD,MAA3B,EAAmC;EAC/B,OAAO2C,wBAAwB,CAAC3C,MAAD,EAAS7D,OAAO,CAACiC,oBAAjB,EAAuC,QAAvC,CAA/B;AACH;;AACDjC,OAAO,CAACK,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,iBAAT,CAA2B0D,MAA3B,EAAmC;EAC/B,OAAO0C,wBAAwB,CAAC1C,MAAD,EAAS9D,OAAO,CAACgC,sBAAjB,EAAyC,QAAzC,CAA/B;AACH;;AACDhC,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,qBAAT,CAA+B4D,UAA/B,EAA2C;EACvC,OAAOyC,wBAAwB,CAACzC,UAAD,EAAa/D,OAAO,CAAC+B,0BAArB,EAAiD,YAAjD,CAA/B;AACH;;AACD/B,OAAO,CAACG,qBAAR,GAAgCA,qBAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASqG,wBAAT,CAAkChH,KAAlC,EAAyCiH,KAAzC,EAAgDC,IAAhD,EAAsD;EAClD,CAAC,GAAGjE,MAAM,CAACkE,qBAAX,EAAkCnH,KAAlC,EAAyCkH,IAAzC;;EACA,IAAI,CAACD,KAAK,CAACvD,QAAN,CAAe1D,KAAf,CAAL,EAA4B;IACxB,MAAM,CAAC,GAAGgD,OAAO,CAACoE,QAAZ,EAAsBF,IAAI,GAAG,8BAAP,GAAwCD,KAAxC,GAAgD,YAAhD,GAA+DjH,KAArF,CAAN;EACH;;EACD,OAAOA,KAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+E,sBAAT,CAAgCX,IAAhC,EAAsCC,MAAtC,EAA8CC,MAA9C,EAAsD;EAClDF,IAAI,GAAG,CAAC,GAAGtB,SAAS,CAACU,GAAd,EAAmBY,IAAnB,CAAP;EACAC,MAAM,GAAG,CAAC,GAAGvB,SAAS,CAACU,GAAd,EAAmBa,MAAnB,CAAT;EACAC,MAAM,GAAG,CAAC,GAAGxB,SAAS,CAACU,GAAd,EAAmBc,MAAnB,CAAT;EACA,IAAI+C,YAAY,GAAGjD,IAAI,CAACK,QAAL,CAAcjE,OAAO,CAAC4B,gBAAtB,CAAnB;EACAiF,YAAY,GAAGA,YAAY,CAAClD,GAAb,CAAiBE,MAAM,CAACI,QAAP,CAAgBjE,OAAO,CAAC6B,kBAAxB,CAAjB,CAAf;EACA,OAAOgF,YAAY,CAAClD,GAAb,CAAiBG,MAAjB,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASa,UAAT,CAAoBT,IAApB,EAA0B;EACtBA,IAAI,GAAG,CAAC,GAAG5B,SAAS,CAACU,GAAd,EAAmBkB,IAAnB,CAAP;;EACA,IAAI,CAACA,IAAI,CAAC4B,MAAL,CAAY,CAAZ,EAAeL,MAAf,CAAsB,CAAtB,CAAL,EAA+B;IAC3B,OAAO,KAAP;EACH,CAFD,MAGK,IAAI,CAACvB,IAAI,CAAC4B,MAAL,CAAY,GAAZ,EAAiBL,MAAjB,CAAwB,CAAxB,CAAL,EAAiC;IAClC,OAAO,IAAP;EACH,CAFI,MAGA,IAAI,CAACvB,IAAI,CAAC4B,MAAL,CAAY,GAAZ,EAAiBL,MAAjB,CAAwB,CAAxB,CAAL,EAAiC;IAClC,OAAO,KAAP;EACH,CAFI,MAGA;IACD,OAAO,IAAP;EACH;AACJ;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASvF,QAAT,CAAkB4G,CAAlB,EAAqBC,CAArB,EAAwB;EACpBD,CAAC,GAAG,CAAC,GAAGxE,SAAS,CAACU,GAAd,EAAmB8D,CAAnB,CAAJ;EACAC,CAAC,GAAG,CAAC,GAAGzE,SAAS,CAACU,GAAd,EAAmB+D,CAAnB,CAAJ;EACA,IAAInH,MAAM,GAAGkH,CAAC,CAACtC,GAAF,CAAMuC,CAAN,CAAb;;EACA,IAAID,CAAC,CAACE,UAAF,OAAmBD,CAAC,CAACC,UAAF,EAAnB,IAAqCpH,MAAM,CAACqE,QAAP,CAAgB8C,CAAhB,EAAmBE,SAAnB,CAA6BH,CAA7B,CAAzC,EAA0E;IACtElH,MAAM,GAAGA,MAAM,CAAC6E,QAAP,CAAgB,CAAhB,CAAT;EACH;;EACD,OAAO7E,MAAP;AACH;;AACDI,OAAO,CAACE,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,QAAT,CAAkB6G,CAAlB,EAAqBC,CAArB,EAAwB;EACpBD,CAAC,GAAG,CAAC,GAAGxE,SAAS,CAACU,GAAd,EAAmB8D,CAAnB,CAAJ;EACAC,CAAC,GAAG,CAAC,GAAGzE,SAAS,CAACU,GAAd,EAAmB+D,CAAnB,CAAJ;EACA,OAAOD,CAAC,CAACrC,QAAF,CAAWvE,QAAQ,CAAC4G,CAAD,EAAIC,CAAJ,CAAR,CAAe9C,QAAf,CAAwB8C,CAAxB,CAAX,CAAP;AACH;;AACD/G,OAAO,CAACC,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;AACA;AACA;;AACA,SAASiF,sCAAT,CAAgDzB,OAAhD,EAAyDC,WAAzD,EAAsE;EAClED,OAAO,GAAG,CAAC,GAAGnB,SAAS,CAACU,GAAd,EAAmBS,OAAnB,CAAV;EACAC,WAAW,GAAG,CAAC,GAAGpB,SAAS,CAACU,GAAd,EAAmBU,WAAnB,CAAd;EACA,IAAIwD,aAAJ;EACA,IAAIC,iBAAJ;EACA,IAAIC,eAAe,GAAG3D,OAAO,CAACiC,UAAR,EAAtB;EACA,IAAI2B,0BAA0B,GAAG3D,WAAW,CAACgB,WAAZ,CAAwB,CAAxB,CAAjC;;EACA,IAAI0C,eAAe,IAAIC,0BAAvB,EAAmD;IAC/C,IAAI5D,OAAO,CAACgC,MAAR,CAAe,CAAC,CAAhB,CAAJ,EAAwB;MACpByB,aAAa,GAAG,IAAhB;IACH,CAFD,MAGK;MACDA,aAAa,GAAGzD,OAAO,CAACE,GAAR,CAAY,CAAZ,EAAeH,QAAf,EAAhB;IACH;EACJ,CAPD,MAQK;IACD0D,aAAa,GAAGzD,OAAO,CAACD,QAAR,EAAhB;EACH;;EACD,IAAI6D,0BAAJ,EAAgC;IAC5B,IAAID,eAAJ,EAAqB;MACjBD,iBAAiB,GAAG5B,gBAAgB,CAAC7B,WAAW,CAC3C4D,MADgC,GAEhC3D,GAFgC,CAE5B,IAAI3D,OAAO,CAAC2B,gBAFgB,EAGhCmE,MAHgC,CAGzB9F,OAAO,CAAC2B,gBAHiB,CAAD,CAApC;IAIH,CALD,MAMK;MACDwF,iBAAiB,GAAG5B,gBAAgB,CAAC7B,WAAW,CAACC,GAAZ,CAAgB3D,OAAO,CAAC2B,gBAAxB,EAA0CmE,MAA1C,CAAiD9F,OAAO,CAAC2B,gBAAzD,CAAD,CAApC;IACH;EACJ;;EACD,OAAOwF,iBAAiB,GAAGD,aAAa,GAAGC,iBAAnB,GAAuCD,aAA/D;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAS3B,gBAAT,CAA0B/F,KAA1B,EAAiC;EAC7BA,KAAK,GAAG,CAAC,GAAG8C,SAAS,CAACU,GAAd,EAAmBxD,KAAnB,CAAR;EACA,OAAOA,KAAK,CAACiG,MAAN,CAAa,CAAb,IAAkB,EAAlB,GAAuB,MAAMV,YAAY,CAACvF,KAAD,EAAQ,CAAR,CAAhD;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASuF,YAAT,CAAsBwC,GAAtB,EAA2BC,YAA3B,EAAyC;EACrCD,GAAG,GAAG,CAAC,GAAGjF,SAAS,CAACU,GAAd,EAAmBuE,GAAnB,CAAN;EACA,IAAI7B,UAAU,GAAG6B,GAAG,CAAC7B,UAAJ,EAAjB;;EACA,IAAIA,UAAJ,EAAgB;IACZ6B,GAAG,GAAGA,GAAG,CAACD,MAAJ,EAAN;EACH;;EACD,IAAIG,SAAS,GAAGF,GAAG,CAAC/D,QAAJ,EAAhB;;EACA,IAAIgE,YAAJ,EAAkB;IACd;IACA,OAAOC,SAAS,CAACC,MAAV,GAAmBF,YAA1B,EAAwC;MACpCC,SAAS,GAAG,MAAMA,SAAlB;IACH;EACJ;;EACD,OAAO/B,UAAU,GAAG,MAAM+B,SAAT,GAAqBA,SAAtC;AACH;;AACD,SAAS9D,GAAT,CAAamD,CAAb,EAAgBC,CAAhB,EAAmB;EACf,IAAID,CAAC,YAAYxE,SAAS,CAACc,OAA3B,EAAoC;IAChC,OAAO0D,CAAC,CAACnD,GAAF,CAAMoD,CAAN,CAAP;EACH,CAFD,MAGK,IAAI,OAAOD,CAAP,KAAa,QAAjB,EAA2B;IAC5B,OAAOA,CAAC,GAAGa,MAAM,CAACZ,CAAD,CAAjB;EACH;;EACD,OAAOD,CAAC,GAAGC,CAAX;AACH"},"metadata":{},"sourceType":"script"}