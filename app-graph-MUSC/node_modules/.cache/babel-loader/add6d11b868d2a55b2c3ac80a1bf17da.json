{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar channel_1 = require(\"../channel\");\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar BOLT_MAGIC_PREAMBLE = 0x6060b017;\n\nfunction version(major, minor) {\n  return {\n    major: major,\n    minor: minor\n  };\n}\n\nfunction createHandshakeMessage(versions) {\n  if (versions.length > 4) {\n    throw (0, neo4j_driver_core_1.newError)('It should not have more than 4 versions of the protocol');\n  }\n\n  var handshakeBuffer = (0, channel_1.alloc)(5 * 4);\n  handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE);\n  versions.forEach(function (version) {\n    if (version instanceof Array) {\n      var _a = version[0],\n          major = _a.major,\n          minor = _a.minor;\n      var minMinor = version[1].minor;\n      var range = minor - minMinor;\n      handshakeBuffer.writeInt32(range << 16 | minor << 8 | major);\n    } else {\n      var major = version.major,\n          minor = version.minor;\n      handshakeBuffer.writeInt32(minor << 8 | major);\n    }\n  });\n  handshakeBuffer.reset();\n  return handshakeBuffer;\n}\n\nfunction parseNegotiatedResponse(buffer) {\n  var h = [buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8(), buffer.readUInt8()];\n\n  if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {\n    throw (0, neo4j_driver_core_1.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' + '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');\n  }\n\n  return Number(h[3] + '.' + h[2]);\n}\n/**\n * @return {BaseBuffer}\n * @private\n */\n\n\nfunction newHandshakeBuffer() {\n  return createHandshakeMessage([[version(4, 4), version(4, 2)], version(4, 1), version(4, 0), version(3, 0)]);\n}\n/**\n * This callback is displayed as a global member.\n * @callback BufferConsumerCallback\n * @param {buffer} buffer the remaining buffer\n */\n\n/**\n * @typedef HandshakeResult\n * @property {number} protocolVersion The protocol version negotiated in the handshake\n * @property {function(BufferConsumerCallback)} consumeRemainingBuffer A function to consume the remaining buffer if it exists\n */\n\n/**\n * Shake hands using the channel and return the protocol version\n *\n * @param {Channel} channel the channel use to shake hands\n * @returns {Promise<HandshakeResult>} Promise of protocol version and consumeRemainingBuffer\n */\n\n\nfunction handshake(channel) {\n  var _this = this;\n\n  return new Promise(function (resolve, reject) {\n    var handshakeErrorHandler = function (error) {\n      reject(error);\n    };\n\n    channel.onerror = handshakeErrorHandler.bind(_this);\n\n    if (channel._error) {\n      handshakeErrorHandler(channel._error);\n    }\n\n    channel.onmessage = function (buffer) {\n      try {\n        // read the response buffer and initialize the protocol\n        var protocolVersion = parseNegotiatedResponse(buffer);\n        resolve({\n          protocolVersion: protocolVersion,\n          consumeRemainingBuffer: function (consumer) {\n            if (buffer.hasRemaining()) {\n              consumer(buffer.readSlice(buffer.remaining()));\n            }\n          }\n        });\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    channel.write(newHandshakeBuffer());\n  });\n}\n\nexports.default = handshake;","map":{"version":3,"names":["Object","defineProperty","exports","value","channel_1","require","neo4j_driver_core_1","BOLT_MAGIC_PREAMBLE","version","major","minor","createHandshakeMessage","versions","length","newError","handshakeBuffer","alloc","writeInt32","forEach","Array","_a","minMinor","range","reset","parseNegotiatedResponse","buffer","h","readUInt8","Number","newHandshakeBuffer","handshake","channel","_this","Promise","resolve","reject","handshakeErrorHandler","error","onerror","bind","_error","onmessage","protocolVersion","consumeRemainingBuffer","consumer","hasRemaining","readSlice","remaining","e","write","default"],"sources":["/Users/zack/src/gene-graph-MUSC/node_modules/neo4j-driver-bolt-connection/lib/bolt/handshake.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"../channel\");\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar BOLT_MAGIC_PREAMBLE = 0x6060b017;\nfunction version(major, minor) {\n    return {\n        major: major,\n        minor: minor\n    };\n}\nfunction createHandshakeMessage(versions) {\n    if (versions.length > 4) {\n        throw (0, neo4j_driver_core_1.newError)('It should not have more than 4 versions of the protocol');\n    }\n    var handshakeBuffer = (0, channel_1.alloc)(5 * 4);\n    handshakeBuffer.writeInt32(BOLT_MAGIC_PREAMBLE);\n    versions.forEach(function (version) {\n        if (version instanceof Array) {\n            var _a = version[0], major = _a.major, minor = _a.minor;\n            var minMinor = version[1].minor;\n            var range = minor - minMinor;\n            handshakeBuffer.writeInt32((range << 16) | (minor << 8) | major);\n        }\n        else {\n            var major = version.major, minor = version.minor;\n            handshakeBuffer.writeInt32((minor << 8) | major);\n        }\n    });\n    handshakeBuffer.reset();\n    return handshakeBuffer;\n}\nfunction parseNegotiatedResponse(buffer) {\n    var h = [\n        buffer.readUInt8(),\n        buffer.readUInt8(),\n        buffer.readUInt8(),\n        buffer.readUInt8()\n    ];\n    if (h[0] === 0x48 && h[1] === 0x54 && h[2] === 0x54 && h[3] === 0x50) {\n        throw (0, neo4j_driver_core_1.newError)('Server responded HTTP. Make sure you are not trying to connect to the http endpoint ' +\n            '(HTTP defaults to port 7474 whereas BOLT defaults to port 7687)');\n    }\n    return Number(h[3] + '.' + h[2]);\n}\n/**\n * @return {BaseBuffer}\n * @private\n */\nfunction newHandshakeBuffer() {\n    return createHandshakeMessage([\n        [version(4, 4), version(4, 2)],\n        version(4, 1),\n        version(4, 0),\n        version(3, 0)\n    ]);\n}\n/**\n * This callback is displayed as a global member.\n * @callback BufferConsumerCallback\n * @param {buffer} buffer the remaining buffer\n */\n/**\n * @typedef HandshakeResult\n * @property {number} protocolVersion The protocol version negotiated in the handshake\n * @property {function(BufferConsumerCallback)} consumeRemainingBuffer A function to consume the remaining buffer if it exists\n */\n/**\n * Shake hands using the channel and return the protocol version\n *\n * @param {Channel} channel the channel use to shake hands\n * @returns {Promise<HandshakeResult>} Promise of protocol version and consumeRemainingBuffer\n */\nfunction handshake(channel) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n        var handshakeErrorHandler = function (error) {\n            reject(error);\n        };\n        channel.onerror = handshakeErrorHandler.bind(_this);\n        if (channel._error) {\n            handshakeErrorHandler(channel._error);\n        }\n        channel.onmessage = function (buffer) {\n            try {\n                // read the response buffer and initialize the protocol\n                var protocolVersion = parseNegotiatedResponse(buffer);\n                resolve({\n                    protocolVersion: protocolVersion,\n                    consumeRemainingBuffer: function (consumer) {\n                        if (buffer.hasRemaining()) {\n                            consumer(buffer.readSlice(buffer.remaining()));\n                        }\n                    }\n                });\n            }\n            catch (e) {\n                reject(e);\n            }\n        };\n        channel.write(newHandshakeBuffer());\n    });\n}\nexports.default = handshake;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}