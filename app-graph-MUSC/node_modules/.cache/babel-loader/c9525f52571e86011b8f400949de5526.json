{"ast":null,"code":"\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Unpacker = exports.Packer = void 0;\n\nvar v1 = __importStar(require(\"./packstream-v1\"));\n\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\n\nvar temporal_factory_1 = require(\"./temporal-factory\");\n\nvar _a = neo4j_driver_core_1.internal.temporalUtil,\n    dateToEpochDay = _a.dateToEpochDay,\n    localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond,\n    localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\n\nvar Packer =\n/** @class */\nfunction (_super) {\n  __extends(Packer, _super);\n\n  function Packer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Packer.prototype.disableByteArrays = function () {\n    throw new Error('Bolt V2 should always support byte arrays');\n  };\n\n  Packer.prototype.packable = function (obj) {\n    var _this = this;\n\n    if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n      return function () {\n        return packPoint(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n      return function () {\n        return packDuration(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n      return function () {\n        return packLocalTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n      return function () {\n        return packTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n      return function () {\n        return packDate(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n      return function () {\n        return packLocalDateTime(obj, _this);\n      };\n    } else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\n      return function () {\n        return packDateTime(obj, _this);\n      };\n    } else {\n      return _super.prototype.packable.call(this, obj);\n    }\n  };\n\n  return Packer;\n}(v1.Packer);\n\nexports.Packer = Packer;\n\nvar Unpacker =\n/** @class */\nfunction (_super) {\n  __extends(Unpacker, _super);\n  /**\n   * @constructor\n   * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n   * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n   */\n\n\n  function Unpacker(disableLosslessIntegers, useBigInt) {\n    if (disableLosslessIntegers === void 0) {\n      disableLosslessIntegers = false;\n    }\n\n    if (useBigInt === void 0) {\n      useBigInt = false;\n    }\n\n    return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n  }\n\n  Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n    if (signature === POINT_2D) {\n      return unpackPoint2D(this, structSize, buffer);\n    } else if (signature === POINT_3D) {\n      return unpackPoint3D(this, structSize, buffer);\n    } else if (signature === DURATION) {\n      return unpackDuration(this, structSize, buffer);\n    } else if (signature === LOCAL_TIME) {\n      return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === TIME) {\n      return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE) {\n      return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === LOCAL_DATE_TIME) {\n      return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n      return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else if (signature === DATE_TIME_WITH_ZONE_ID) {\n      return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    } else {\n      return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n    }\n  };\n\n  return Unpacker;\n}(v1.Unpacker);\n\nexports.Unpacker = Unpacker;\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\nfunction packPoint(point, packer) {\n  var is2DPoint = point.z === null || point.z === undefined;\n\n  if (is2DPoint) {\n    packPoint2D(point, packer);\n  } else {\n    packPoint3D(point, packer);\n  }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint2D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y)];\n  packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packPoint3D(point, packer) {\n  var packableStructFields = [packer.packable((0, neo4j_driver_core_1.int)(point.srid)), packer.packable(point.x), packer.packable(point.y), packer.packable(point.z)];\n  packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\n\n\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  undefined // z\n  );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\n\n\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n\n  return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n  unpacker.unpack(buffer), // x\n  unpacker.unpack(buffer), // y\n  unpacker.unpack(buffer) // z\n  );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDuration(value, packer) {\n  var months = (0, neo4j_driver_core_1.int)(value.months);\n  var days = (0, neo4j_driver_core_1.int)(value.days);\n  var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n  var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n  var packableStructFields = [packer.packable(months), packer.packable(days), packer.packable(seconds), packer.packable(nanoseconds)];\n  packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\n\n\nfunction unpackDuration(unpacker, structSize, buffer) {\n  unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n\n  var months = unpacker.unpack(buffer);\n  var days = unpacker.unpack(buffer);\n  var seconds = unpacker.unpack(buffer);\n  var nanoseconds = unpacker.unpack(buffer);\n  return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var packableStructFields = [packer.packable(nanoOfDay)];\n  packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\n\n\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n  unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packTime(value, packer) {\n  var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n  var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(nanoOfDay), packer.packable(offsetSeconds)];\n  packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\n\n\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n\n  var nanoOfDay = unpacker.unpackInteger(buffer);\n  var offsetSeconds = unpacker.unpackInteger(buffer);\n  var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n  var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDate(value, packer) {\n  var epochDay = dateToEpochDay(value.year, value.month, value.day);\n  var packableStructFields = [packer.packable(epochDay)];\n  packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\n\n\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n\n  var epochDay = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packLocalDateTime(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano)];\n  packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\n\n\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTime(value, packer) {\n  if (value.timeZoneId) {\n    packDateTimeWithZoneId(value, packer);\n  } else {\n    packDateTimeWithZoneOffset(value, packer);\n  }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneOffset(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneOffsetSeconds)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\n\n\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\n\n\nfunction packDateTimeWithZoneId(value, packer) {\n  var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n  var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n  var timeZoneId = value.timeZoneId;\n  var packableStructFields = [packer.packable(epochSecond), packer.packable(nano), packer.packable(timeZoneId)];\n  packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\n\n\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n  unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n\n  var epochSecond = unpacker.unpackInteger(buffer);\n  var nano = unpacker.unpackInteger(buffer);\n  var timeZoneId = unpacker.unpack(buffer);\n  var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n  var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n  return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n  if (!disableLosslessIntegers && !useBigInt) {\n    return obj;\n  }\n\n  var convert = function (value) {\n    return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n  };\n\n  var clone = Object.create(Object.getPrototypeOf(obj));\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      var value = obj[prop];\n      clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n    }\n  }\n\n  Object.freeze(clone);\n  return clone;\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__createBinding","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","exports","Unpacker","Packer","v1","require","neo4j_driver_core_1","temporal_factory_1","_a","internal","temporalUtil","dateToEpochDay","localDateTimeToEpochSecond","localTimeToNanoOfDay","POINT_2D","POINT_2D_STRUCT_SIZE","POINT_3D","POINT_3D_STRUCT_SIZE","DURATION","DURATION_STRUCT_SIZE","LOCAL_TIME","LOCAL_TIME_STRUCT_SIZE","TIME","TIME_STRUCT_SIZE","DATE","DATE_STRUCT_SIZE","LOCAL_DATE_TIME","LOCAL_DATE_TIME_STRUCT_SIZE","DATE_TIME_WITH_ZONE_OFFSET","DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE","DATE_TIME_WITH_ZONE_ID","DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE","_super","apply","arguments","disableByteArrays","Error","packable","obj","_this","isPoint","packPoint","isDuration","packDuration","isLocalTime","packLocalTime","isTime","packTime","isDate","packDate","isLocalDateTime","packLocalDateTime","isDateTime","packDateTime","disableLosslessIntegers","useBigInt","_unpackUnknownStruct","signature","structSize","buffer","unpackPoint2D","unpackPoint3D","unpackDuration","unpackLocalTime","_disableLosslessIntegers","_useBigInt","unpackTime","unpackDate","unpackLocalDateTime","unpackDateTimeWithZoneOffset","unpackDateTimeWithZoneId","point","packer","is2DPoint","z","packPoint2D","packPoint3D","packableStructFields","int","srid","x","y","packStruct","unpacker","_verifyStructSize","Point","unpack","months","days","seconds","nanoseconds","Duration","nanoOfDay","hour","minute","second","nanosecond","unpackInteger","nanoOfDayToLocalTime","convertIntegerPropsIfNeeded","offsetSeconds","timeZoneOffsetSeconds","localTime","Time","epochDay","year","month","day","epochDayToDate","epochSecond","nano","epochSecondAndNanoToLocalDateTime","timeZoneId","packDateTimeWithZoneId","packDateTimeWithZoneOffset","localDateTime","DateTime","convert","toBigInt","toNumberOrInfinity","clone","getPrototypeOf","prop","isInt","freeze"],"sources":["/Users/zack/src/gene3/node_modules/neo4j-driver-bolt-connection/lib/packstream/packstream-v2.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright (c) \"Neo4j\"\n * Neo4j Sweden AB [http://neo4j.com]\n *\n * This file is part of Neo4j.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Unpacker = exports.Packer = void 0;\nvar v1 = __importStar(require(\"./packstream-v1\"));\nvar neo4j_driver_core_1 = require(\"neo4j-driver-core\");\nvar temporal_factory_1 = require(\"./temporal-factory\");\nvar _a = neo4j_driver_core_1.internal.temporalUtil, dateToEpochDay = _a.dateToEpochDay, localDateTimeToEpochSecond = _a.localDateTimeToEpochSecond, localTimeToNanoOfDay = _a.localTimeToNanoOfDay;\nvar POINT_2D = 0x58;\nvar POINT_2D_STRUCT_SIZE = 3;\nvar POINT_3D = 0x59;\nvar POINT_3D_STRUCT_SIZE = 4;\nvar DURATION = 0x45;\nvar DURATION_STRUCT_SIZE = 4;\nvar LOCAL_TIME = 0x74;\nvar LOCAL_TIME_STRUCT_SIZE = 1;\nvar TIME = 0x54;\nvar TIME_STRUCT_SIZE = 2;\nvar DATE = 0x44;\nvar DATE_STRUCT_SIZE = 1;\nvar LOCAL_DATE_TIME = 0x64;\nvar LOCAL_DATE_TIME_STRUCT_SIZE = 2;\nvar DATE_TIME_WITH_ZONE_OFFSET = 0x46;\nvar DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE = 3;\nvar DATE_TIME_WITH_ZONE_ID = 0x66;\nvar DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE = 3;\nvar Packer = /** @class */ (function (_super) {\n    __extends(Packer, _super);\n    function Packer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Packer.prototype.disableByteArrays = function () {\n        throw new Error('Bolt V2 should always support byte arrays');\n    };\n    Packer.prototype.packable = function (obj) {\n        var _this = this;\n        if ((0, neo4j_driver_core_1.isPoint)(obj)) {\n            return function () { return packPoint(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDuration)(obj)) {\n            return function () { return packDuration(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isLocalTime)(obj)) {\n            return function () { return packLocalTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isTime)(obj)) {\n            return function () { return packTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDate)(obj)) {\n            return function () { return packDate(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isLocalDateTime)(obj)) {\n            return function () { return packLocalDateTime(obj, _this); };\n        }\n        else if ((0, neo4j_driver_core_1.isDateTime)(obj)) {\n            return function () { return packDateTime(obj, _this); };\n        }\n        else {\n            return _super.prototype.packable.call(this, obj);\n        }\n    };\n    return Packer;\n}(v1.Packer));\nexports.Packer = Packer;\nvar Unpacker = /** @class */ (function (_super) {\n    __extends(Unpacker, _super);\n    /**\n     * @constructor\n     * @param {boolean} disableLosslessIntegers if this unpacker should convert all received integers to native JS numbers.\n     * @param {boolean} useBigInt if this unpacker should convert all received integers to Bigint\n     */\n    function Unpacker(disableLosslessIntegers, useBigInt) {\n        if (disableLosslessIntegers === void 0) { disableLosslessIntegers = false; }\n        if (useBigInt === void 0) { useBigInt = false; }\n        return _super.call(this, disableLosslessIntegers, useBigInt) || this;\n    }\n    Unpacker.prototype._unpackUnknownStruct = function (signature, structSize, buffer) {\n        if (signature === POINT_2D) {\n            return unpackPoint2D(this, structSize, buffer);\n        }\n        else if (signature === POINT_3D) {\n            return unpackPoint3D(this, structSize, buffer);\n        }\n        else if (signature === DURATION) {\n            return unpackDuration(this, structSize, buffer);\n        }\n        else if (signature === LOCAL_TIME) {\n            return unpackLocalTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === TIME) {\n            return unpackTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE) {\n            return unpackDate(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === LOCAL_DATE_TIME) {\n            return unpackLocalDateTime(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE_TIME_WITH_ZONE_OFFSET) {\n            return unpackDateTimeWithZoneOffset(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else if (signature === DATE_TIME_WITH_ZONE_ID) {\n            return unpackDateTimeWithZoneId(this, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n        else {\n            return _super.prototype._unpackUnknownStruct.call(this, signature, structSize, buffer, this._disableLosslessIntegers, this._useBigInt);\n        }\n    };\n    return Unpacker;\n}(v1.Unpacker));\nexports.Unpacker = Unpacker;\n/**\n * Pack given 2D or 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint(point, packer) {\n    var is2DPoint = point.z === null || point.z === undefined;\n    if (is2DPoint) {\n        packPoint2D(point, packer);\n    }\n    else {\n        packPoint3D(point, packer);\n    }\n}\n/**\n * Pack given 2D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint2D(point, packer) {\n    var packableStructFields = [\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\n        packer.packable(point.x),\n        packer.packable(point.y)\n    ];\n    packer.packStruct(POINT_2D, packableStructFields);\n}\n/**\n * Pack given 3D point.\n * @param {Point} point the point value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packPoint3D(point, packer) {\n    var packableStructFields = [\n        packer.packable((0, neo4j_driver_core_1.int)(point.srid)),\n        packer.packable(point.x),\n        packer.packable(point.y),\n        packer.packable(point.z)\n    ];\n    packer.packStruct(POINT_3D, packableStructFields);\n}\n/**\n * Unpack 2D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 2D point value.\n */\nfunction unpackPoint2D(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Point2D', POINT_2D_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n    unpacker.unpack(buffer), // x\n    unpacker.unpack(buffer), // y\n    undefined // z\n    );\n}\n/**\n * Unpack 3D point value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Point} the unpacked 3D point value.\n */\nfunction unpackPoint3D(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Point3D', POINT_3D_STRUCT_SIZE, structSize);\n    return new neo4j_driver_core_1.Point(unpacker.unpack(buffer), // srid\n    unpacker.unpack(buffer), // x\n    unpacker.unpack(buffer), // y\n    unpacker.unpack(buffer) // z\n    );\n}\n/**\n * Pack given duration.\n * @param {Duration} value the duration value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDuration(value, packer) {\n    var months = (0, neo4j_driver_core_1.int)(value.months);\n    var days = (0, neo4j_driver_core_1.int)(value.days);\n    var seconds = (0, neo4j_driver_core_1.int)(value.seconds);\n    var nanoseconds = (0, neo4j_driver_core_1.int)(value.nanoseconds);\n    var packableStructFields = [\n        packer.packable(months),\n        packer.packable(days),\n        packer.packable(seconds),\n        packer.packable(nanoseconds)\n    ];\n    packer.packStruct(DURATION, packableStructFields);\n}\n/**\n * Unpack duration value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @return {Duration} the unpacked duration value.\n */\nfunction unpackDuration(unpacker, structSize, buffer) {\n    unpacker._verifyStructSize('Duration', DURATION_STRUCT_SIZE, structSize);\n    var months = unpacker.unpack(buffer);\n    var days = unpacker.unpack(buffer);\n    var seconds = unpacker.unpack(buffer);\n    var nanoseconds = unpacker.unpack(buffer);\n    return new neo4j_driver_core_1.Duration(months, days, seconds, nanoseconds);\n}\n/**\n * Pack given local time.\n * @param {LocalTime} value the local time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalTime(value, packer) {\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n    var packableStructFields = [packer.packable(nanoOfDay)];\n    packer.packStruct(LOCAL_TIME, packableStructFields);\n}\n/**\n * Unpack local time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local time should be native JS numbers.\n * @return {LocalTime} the unpacked local time value.\n */\nfunction unpackLocalTime(unpacker, structSize, buffer, disableLosslessIntegers) {\n    unpacker._verifyStructSize('LocalTime', LOCAL_TIME_STRUCT_SIZE, structSize);\n    var nanoOfDay = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers);\n}\n/**\n * Pack given time.\n * @param {Time} value the time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packTime(value, packer) {\n    var nanoOfDay = localTimeToNanoOfDay(value.hour, value.minute, value.second, value.nanosecond);\n    var offsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n    var packableStructFields = [\n        packer.packable(nanoOfDay),\n        packer.packable(offsetSeconds)\n    ];\n    packer.packStruct(TIME, packableStructFields);\n}\n/**\n * Unpack time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result time should be native JS numbers.\n * @return {Time} the unpacked time value.\n */\nfunction unpackTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('Time', TIME_STRUCT_SIZE, structSize);\n    var nanoOfDay = unpacker.unpackInteger(buffer);\n    var offsetSeconds = unpacker.unpackInteger(buffer);\n    var localTime = (0, temporal_factory_1.nanoOfDayToLocalTime)(nanoOfDay);\n    var result = new neo4j_driver_core_1.Time(localTime.hour, localTime.minute, localTime.second, localTime.nanosecond, offsetSeconds);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given neo4j date.\n * @param {Date} value the date value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDate(value, packer) {\n    var epochDay = dateToEpochDay(value.year, value.month, value.day);\n    var packableStructFields = [packer.packable(epochDay)];\n    packer.packStruct(DATE, packableStructFields);\n}\n/**\n * Unpack neo4j date value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date should be native JS numbers.\n * @return {Date} the unpacked neo4j date value.\n */\nfunction unpackDate(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('Date', DATE_STRUCT_SIZE, structSize);\n    var epochDay = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.epochDayToDate)(epochDay);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given local date time.\n * @param {LocalDateTime} value the local date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packLocalDateTime(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano)\n    ];\n    packer.packStruct(LOCAL_DATE_TIME, packableStructFields);\n}\n/**\n * Unpack local date time value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result local date-time should be native JS numbers.\n * @return {LocalDateTime} the unpacked local date time value.\n */\nfunction unpackLocalDateTime(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('LocalDateTime', LOCAL_DATE_TIME_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var result = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTime(value, packer) {\n    if (value.timeZoneId) {\n        packDateTimeWithZoneId(value, packer);\n    }\n    else {\n        packDateTimeWithZoneOffset(value, packer);\n    }\n}\n/**\n * Pack given date time with zone offset.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneOffset(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var timeZoneOffsetSeconds = (0, neo4j_driver_core_1.int)(value.timeZoneOffsetSeconds);\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano),\n        packer.packable(timeZoneOffsetSeconds)\n    ];\n    packer.packStruct(DATE_TIME_WITH_ZONE_OFFSET, packableStructFields);\n}\n/**\n * Unpack date time with zone offset value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone offset value.\n */\nfunction unpackDateTimeWithZoneOffset(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('DateTimeWithZoneOffset', DATE_TIME_WITH_ZONE_OFFSET_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var timeZoneOffsetSeconds = unpacker.unpackInteger(buffer);\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, timeZoneOffsetSeconds, null);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\n/**\n * Pack given date time with zone id.\n * @param {DateTime} value the date time value to pack.\n * @param {Packer} packer the packer to use.\n */\nfunction packDateTimeWithZoneId(value, packer) {\n    var epochSecond = localDateTimeToEpochSecond(value.year, value.month, value.day, value.hour, value.minute, value.second, value.nanosecond);\n    var nano = (0, neo4j_driver_core_1.int)(value.nanosecond);\n    var timeZoneId = value.timeZoneId;\n    var packableStructFields = [\n        packer.packable(epochSecond),\n        packer.packable(nano),\n        packer.packable(timeZoneId)\n    ];\n    packer.packStruct(DATE_TIME_WITH_ZONE_ID, packableStructFields);\n}\n/**\n * Unpack date time with zone id value using the given unpacker.\n * @param {Unpacker} unpacker the unpacker to use.\n * @param {number} structSize the retrieved struct size.\n * @param {BaseBuffer} buffer the buffer to unpack from.\n * @param {boolean} disableLosslessIntegers if integer properties in the result date-time should be native JS numbers.\n * @return {DateTime} the unpacked date time with zone id value.\n */\nfunction unpackDateTimeWithZoneId(unpacker, structSize, buffer, disableLosslessIntegers, useBigInt) {\n    unpacker._verifyStructSize('DateTimeWithZoneId', DATE_TIME_WITH_ZONE_ID_STRUCT_SIZE, structSize);\n    var epochSecond = unpacker.unpackInteger(buffer);\n    var nano = unpacker.unpackInteger(buffer);\n    var timeZoneId = unpacker.unpack(buffer);\n    var localDateTime = (0, temporal_factory_1.epochSecondAndNanoToLocalDateTime)(epochSecond, nano);\n    var result = new neo4j_driver_core_1.DateTime(localDateTime.year, localDateTime.month, localDateTime.day, localDateTime.hour, localDateTime.minute, localDateTime.second, localDateTime.nanosecond, null, timeZoneId);\n    return convertIntegerPropsIfNeeded(result, disableLosslessIntegers, useBigInt);\n}\nfunction convertIntegerPropsIfNeeded(obj, disableLosslessIntegers, useBigInt) {\n    if (!disableLosslessIntegers && !useBigInt) {\n        return obj;\n    }\n    var convert = function (value) {\n        return useBigInt ? value.toBigInt() : value.toNumberOrInfinity();\n    };\n    var clone = Object.create(Object.getPrototypeOf(obj));\n    for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n            var value = obj[prop];\n            clone[prop] = (0, neo4j_driver_core_1.isInt)(value) ? convert(value) : value;\n        }\n    }\n    Object.freeze(clone);\n    return clone;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}